name: ⚡ Test1 API Zero Downtime Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18'

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
      package-hash: ${{ steps.hash.outputs.package-hash }}
    steps:
      - name: 📋 Checkout
        uses: actions/checkout@v4

      - name: 📊 Generate Metadata
        id: meta
        run: |
          DEPLOYMENT_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "🆔 Deployment ID: $DEPLOYMENT_ID"

      - name: 📊 Generate Package Hash
        id: hash
        run: |
          PACKAGE_HASH=$(sha256sum package.json package-lock.json | sha256sum | cut -d ' ' -f 1)
          echo "package-hash=$PACKAGE_HASH" >> $GITHUB_OUTPUT
          echo "📦 Package Hash: $PACKAGE_HASH"

      - name: ♻️ Cache Node Modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: ⚡ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 🔧 Install Dependencies
        run: |
          if [ ! -d "node_modules" ] || [ "$(find node_modules -maxdepth 0 -empty 2>/dev/null)" ]; then
            npm ci --prefer-offline --no-audit --progress=false
          else
            echo "📦 Using cached dependencies"
          fi

      - name: 🏗️ Build Application
        run: |
          npm run build
      - name: 📦 Create Deployment Package
        run: |
          # Create comprehensive deployment package
          
          # Include all necessary files and directories
          tar -czf deployment.tar.gz \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='*.log' \
            --exclude='coverage' \
            --exclude='.nyc_output' \
            .next \
            node_modules \
            public \
            package.json \
            package-lock.json \
            $(find . -name "next.config.*" -type f) \
            $(find . -maxdepth 1 -type d -name "app" -o -name "pages" -o -name "styles" -o -name "components" -o -name "lib" -o -name "utils" -o -name "hooks" -o -name "types" -o -name "src") \
            $(find . -maxdepth 1 -name "*.config.*" -type f) \
            $(find . -maxdepth 1 -name "tsconfig.json" -o -name "tailwind.config.*" -o -name "postcss.config.*" -type f)
          
          echo "📦 Package size: $(du -sh deployment.tar.gz | cut -f1)"

      - name: 🚀 Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ steps.meta.outputs.deployment-id }}
          path: deployment.tar.gz
          retention-days: 1

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: 📥 Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-${{ needs.build.outputs.deployment-id }}
          path: .

      - name: ⚙️ Setup Environment
        run: |
          BRANCH=${GITHUB_REF##*/}
          
          if [ "$BRANCH" = "main" ]; then
            echo "DEPLOY_PATH=${{ secrets.PROD_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.PROD_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.PROD_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.PROD_SSH_PORT }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.PROD_PROCESS_NAME}}" >> $GITHUB_ENV
            echo "PORT_A=${{ secrets.PROD_PORT_A}}" >> $GITHUB_ENV
            echo "PORT_B=${{ secrets.PROD_PORT_B}}" >> $GITHUB_ENV
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          else
            echo "DEPLOY_PATH=${{ secrets.DEV_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.DEV_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.DEV_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.DEV_SSH_PORT }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.DEV_PROCESS_NAME}}" >> $GITHUB_ENV
            echo "PORT_A=${{ secrets.DEV_PORT_A}}" >> $GITHUB_ENV
            echo "PORT_B=${{ secrets.DEV_PORT_B}}" >> $GITHUB_ENV
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
          fi
          
          echo "DEPLOYMENT_ID=${{ needs.build.outputs.deployment-id }}" >> $GITHUB_ENV
          echo "PACKAGE_HASH=${{ needs.build.outputs.package-hash }}" >> $GITHUB_ENV

      - name: 🔐 Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo '${{ secrets.PROD_SSH_PRIVATE_KEY }}' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          cat > ~/.ssh/config << EOF
          Host deploy
            HostName $SERVER
            User $USER
            Port $PORT_SSH
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            ServerAliveInterval 30
            ConnectTimeout 10
          EOF

      - name: 🚀 Zero-Downtime Deploy with Proper File Management
        run: |
          # Create deployment directory with timestamp
          DEPLOY_DIR="${{ env.DEPLOYMENT_ID }}"
          
          echo "📤 Creating deployment directory: $DEPLOY_DIR"
          ssh deploy "mkdir -p ${{ env.DEPLOY_PATH }}/deployments/$DEPLOY_DIR"
          
          # Upload deployment package to timestamped directory
          echo "📤 Uploading deployment package..."
          scp deployment.tar.gz deploy:${{ env.DEPLOY_PATH }}/deployments/$DEPLOY_DIR/deployment.tar.gz
          
          # Copy environment variables
          echo '${{ secrets.PROD_ENV_SECRET }}' | ssh deploy "cat > ${{ env.DEPLOY_PATH }}/deployments/$DEPLOY_DIR/.env"
          
          # Execute deployment with proper file management
          ssh deploy << 'DEPLOY_SCRIPT'
            set -e
            
            # Setup paths
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            DEPLOYMENT_ID="${{ env.DEPLOYMENT_ID }}"
            NEW_DEPLOYMENT_PATH="$DEPLOY_PATH/deployments/$DEPLOYMENT_ID"
            CURRENT_PATH="$DEPLOY_PATH/current"
            BACKUP_PATH="$DEPLOY_PATH/backup"
            STAGING_PATH="$DEPLOY_PATH/staging"
            
            # Create necessary directories
            mkdir -p "$NEW_DEPLOYMENT_PATH" "$CURRENT_PATH" "$BACKUP_PATH" "$STAGING_PATH" "$DEPLOY_PATH/logs"
            
            cd "$NEW_DEPLOYMENT_PATH"
            
            # Extract deployment package
            tar -xzf deployment.tar.gz
            rm deployment.tar.gz
            
            # Verify extraction
            echo "🔍 Verifying extracted files..."
            ls -la
            
            if [ ! -f "package.json" ]; then
              echo "❌ package.json not found after extraction"
              exit 1
            fi
            
            if [ ! -d ".next" ]; then
              echo "❌ .next directory not found after extraction"
              exit 1
            fi
            
            # Check current Nginx upstream port
            CURRENT_PORT=""
            if [ -f "/etc/nginx/conf.d/test1_backend.conf" ]; then
              CURRENT_PORT=$(grep -o "127.0.0.1:[0-9]*" /etc/nginx/conf.d/test1_backend.conf | cut -d: -f2)
            fi
            
            # Default to ${{ env.PORT_A }} if no port found
            if [ -z "$CURRENT_PORT" ]; then
              CURRENT_PORT="${{ env.PORT_A }}"
            fi
            
            # Determine new port (switch between ${{ env.PORT_A }} and ${{ env.PORT_B }})
            if [ "$CURRENT_PORT" = "${{ env.PORT_A }}" ]; then
              NEW_PORT="${{ env.PORT_B }}"
              NEW_PROCESS="${{ env.PROCESS_NAME }}-b"
              OLD_PROCESS="${{ env.PROCESS_NAME }}-a"
            else
              NEW_PORT="${{ env.PORT_A }}"
              NEW_PROCESS="${{ env.PROCESS_NAME }}-a"
              OLD_PROCESS="${{ env.PROCESS_NAME }}-b"
            fi
            
            # Install/verify dependencies
            
            if [ ! -d "node_modules" ] || [ ! -f "node_modules/.bin/next" ]; then
              npm ci --production=false --prefer-offline=false --no-audit --no-fund
            else
              echo "✅ Dependencies already present"
            fi
            
            # Verify Next.js installation
            if [ ! -f "node_modules/.bin/next" ]; then
              echo "❌ Next.js binary not found"
              exit 1
            fi
            
            # Add environment variables
            echo "PORT=$NEW_PORT" >> .env
            echo "NODE_ENV=production" >> .env
            echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> .env
            
            # Create PM2 ecosystem configuration
            cat > ecosystem.config.cjs << EOF
          module.exports = {
            apps: [{
              name: '$NEW_PROCESS',
              script: './node_modules/.bin/next',
              args: 'start',
              cwd: '$NEW_DEPLOYMENT_PATH',
              instances: 1,
              exec_mode: 'cluster',
              env: {
                NODE_ENV: 'production',
                PORT: '$NEW_PORT',
                PWD: '$NEW_DEPLOYMENT_PATH',
                NEXT_TELEMETRY_DISABLED: '1'
              },
              max_memory_restart: '512M',
              min_uptime: '10s',
              max_restarts: 3,
              autorestart: true,
              watch: false,
              kill_timeout: 8000,
              wait_ready: true,
              listen_timeout: 15000,
              error_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-error.log',
              out_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-out.log',
              log_file: '$DEPLOY_PATH/logs/$NEW_PROCESS.log',
              time: true
            }]
          };
          EOF
            
            # Start new process
            pm2 start ecosystem.config.cjs
            
            # Health check function
            health_check() {
              local port=$1
              local attempts=0
              local max_attempts=30
              
              while [ $attempts -lt $max_attempts ]; do
                if curl -f -s --max-time 3 "http://localhost:$port/api/health" > /dev/null 2>&1; then
                  return 0
                fi
                attempts=$((attempts + 1))
                echo "🔄 Health check attempt $attempts/$max_attempts on port $port..."
                sleep 2
              done
              
              echo "❌ Health check failed after $max_attempts attempts"
              return 1
            }
            
            # Wait for new process to be ready
            echo "⏳ Waiting for new process to be ready..."
            sleep 10
            
            if health_check $NEW_PORT; then
              
              # Update Nginx upstream
              echo "🔄 Updating Nginx to point to port $NEW_PORT..."
              
              sudo tee "/etc/nginx/conf.d/test1_backend.conf" > /dev/null << EOF
          upstream test1_backend {
              server 127.0.0.1:$NEW_PORT;
          }
          EOF
              
              # Test and reload Nginx
              if sudo nginx -t; then
                sudo nginx -s reload
                
                # Wait for Nginx to pick up changes
                sleep 3
                
                # Verify the switch worked
                if curl -f -s --max-time 5 "https://$SERVER/api/health" > /dev/null 2>&1; then
                  
                  # Stop old process if it exists
                  if pm2 describe $OLD_PROCESS > /dev/null 2>&1; then
                    echo "🛑 Gracefully stopping old process: $OLD_PROCESS"
                    pm2 stop $OLD_PROCESS
                    sleep 2
                    pm2 delete $OLD_PROCESS
                  fi
                  
                  # Update symlinks and preserve staging
                  echo "🔄 Updating current deployment symlink..."
                  
                  # Backup current if it exists
                  if [ -L "$CURRENT_PATH" ] || [ -d "$CURRENT_PATH" ]; then
                    rm -rf "$BACKUP_PATH"
                    if [ -L "$CURRENT_PATH" ]; then
                      cp -P "$CURRENT_PATH" "$BACKUP_PATH" 2>/dev/null || true
                    else
                      mv "$CURRENT_PATH" "$BACKUP_PATH" 2>/dev/null || true
                    fi
                  fi
                  
                  # Create new current symlink
                  ln -sfn "$NEW_DEPLOYMENT_PATH" "$CURRENT_PATH"
                  
                  # Copy deployment to staging for reference (not move!)
                  rm -rf "$STAGING_PATH"/*
                  cp -r "$NEW_DEPLOYMENT_PATH"/* "$STAGING_PATH/"
                  
                  # Save PM2 configuration
                  pm2 save
                  
                  # Cleanup old deployments (keep last 3)
                  cd "$DEPLOY_PATH/deployments"
                  ls -t | tail -n +4 | xargs -r rm -rf
                  
                else
                  echo "❌ External health check failed after Nginx switch"
                  
                  # Rollback Nginx config
                  if [ -n "$CURRENT_PORT" ]; then
                    echo "🔄 Rolling back Nginx to port $CURRENT_PORT..."
                    sudo tee "/etc/nginx/conf.d/test1_backend.conf" > /dev/null << EOF
          upstream test1_backend {
              server 127.0.0.1:$CURRENT_PORT;
          }
          EOF
                    sudo nginx -s reload
                  fi
                  
                  # Stop failed process
                  pm2 stop $NEW_PROCESS || true
                  pm2 delete $NEW_PROCESS || true
                  
                  exit 1
                fi
              else
                echo "❌ Nginx configuration test failed"
                pm2 stop $NEW_PROCESS || true
                pm2 delete $NEW_PROCESS || true
                exit 1
              fi
              
            else
              echo "❌ New process failed health check"
              pm2 stop $NEW_PROCESS || true
              pm2 delete $NEW_PROCESS || true
              exit 1
            fi
          DEPLOY_SCRIPT

      - name: 🔍 Verify Deployment
        run: |
          ssh deploy << 'VERIFY_SCRIPT'
            echo "📊 PM2 Status:"
            pm2 status
            
            echo ""
            echo "🌐 External Health Check:"
            curl -s https://$SERVER/api/health
            
            echo ""
            echo "🔧 Nginx Upstream Config:"
            cat /etc/nginx/conf.d/test1_backend.conf
            
            echo ""
            echo "📋 Active Processes:"
            netstat -tuln | grep -E ":(${{ env.PORT_A }}|${{ env.PORT_B }}) "
            
            echo ""
            echo "🔗 Current Directory (symlink):"
            ls -la ${{ env.DEPLOY_PATH }}/current
            
            echo ""
            echo "📂 Staging Directory Contents:"
            ls -la ${{ env.DEPLOY_PATH }}/staging
            
            echo ""
            echo "📦 Deployments Directory:"
            ls -la ${{ env.DEPLOY_PATH }}/deployments
            
            echo ""
            echo "📦 Next.js Version:"
            cd ${{ env.DEPLOY_PATH }}/current && node -e "console.log('Next.js version:', require('./node_modules/next/package.json').version)"
          VERIFY_SCRIPT

      - name: 🧹 Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key deployment.tar.gz
          echo "✅ Cleanup completed"

  notify:
    needs: [build, deploy]
    runs-on: self-hosted
    if: always()
    steps:
      - name: 📢 Deployment Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "🌍 Environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}"
          else
            echo "❌ Test1 API deployment failed!"
            echo "🆔 ID: ${{ needs.build.outputs.deployment-id }}"
            echo "🔍 Check the logs above for details"
          fi