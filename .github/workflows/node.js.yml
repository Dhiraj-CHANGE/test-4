name: ‚ö° Lightning Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18'

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
      package-hash: ${{ steps.hash.outputs.package-hash }}
    steps:
      - name: üìã Checkout
        uses: actions/checkout@v4

      - name: üìä Generate Metadata
        id: meta
        run: |
          DEPLOYMENT_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "üÜî Deployment ID: $DEPLOYMENT_ID"

      - name: üìä Generate Package Hash
        id: hash
        run: |
          PACKAGE_HASH=$(sha256sum package.json | cut -d ' ' -f 1)
          echo "package-hash=$PACKAGE_HASH" >> $GITHUB_OUTPUT
          echo "üì¶ Package Hash: $PACKAGE_HASH"

      - name: ‚ö° Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üîß Install Dependencies
        run: |
          npm ci --prefer-offline --no-audit --progress=false
          echo "‚úÖ Dependencies installed"

      - name: üèóÔ∏è Build Application
        run: |
          npm run build
          echo "‚úÖ Build completed"

      - name: üì¶ Create Optimized Package
        run: |
          # Create minimal production package
          mkdir -p dist
          
          # Verify .next directory exists
          if [ ! -d ".next" ]; then
            echo "‚ùå .next directory not found. Build may have failed."
            exit 1
          fi
          
          # Copy Next.js build output for Pages Router
          cp -r .next dist/
          
          # Copy essential directories (only if they exist)
          [ -d "pages" ] && cp -r pages dist/ || echo "No pages directory found"
          [ -d "public" ] && cp -r public dist/ || echo "No public directory found"
          [ -d "styles" ] && cp -r styles dist/ || echo "No styles directory"
          [ -d "components" ] && cp -r components dist/ || echo "No components directory"
          [ -d "lib" ] && cp -r lib dist/ || echo "No lib directory"
          [ -d "utils" ] && cp -r utils dist/ || echo "No utils directory"
          [ -d "hooks" ] && cp -r hooks dist/ || echo "No hooks directory"
          [ -d "scripts" ] && cp -r scripts dist/ || echo "No scripts directory"
          [ -d "app" ] && cp -r app dist/ || echo "No app directory"
          
          # Copy package files
          cp package.json package-lock.json dist/
          
          # Copy Next.js config if it exists
          [ -f "next.config.js" ] && cp next.config.js dist/ || echo "No next.config.js"
          [ -f "next.config.mjs" ] && cp next.config.mjs dist/ || echo "No next.config.mjs"
          
          # Create deployment info file
          cat > dist/deployment-info.json << EOF
          {
            "id": "${{ steps.meta.outputs.deployment-id }}",
            "branch": "${GITHUB_REF##*/}",
            "commit": "${GITHUB_SHA}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "size": "$(du -sh dist | cut -f1)",
            "router": "pages",
            "package_hash": "${{ steps.hash.outputs.package-hash }}"
          }
          EOF
          echo "üì¶ Package size: $(du -sh dist | cut -f1)"

      - name: üöÄ Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ steps.meta.outputs.deployment-id }}
          path: dist
          retention-days: 1
          compression-level: 9

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: üì• Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-${{ needs.build.outputs.deployment-id }}
          path: dist

      - name: ‚öôÔ∏è Setup Environment
        id: env
        run: |
          BRANCH=${GITHUB_REF##*/}
          DEPLOYMENT_ID="${{ needs.build.outputs.deployment-id }}"
          PACKAGE_HASH="${{ needs.build.outputs.package-hash }}"
          
          # Create temporary files for secure handling
          TEMP_DIR=$(mktemp -d)
          
          if [ "$BRANCH" = "main" ]; then
            # Production environment
            echo "DEPLOY_PATH=${{ secrets.PROD_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.PROD_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.PROD_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.PROD_SSH_PORT }}" >> $GITHUB_ENV
            echo "PORT_APP=5005" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.PROD_PROCESS_NAME}}" >> $GITHUB_ENV
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
            
            # Handle multiline secrets safely
            printf '%s' '${{ secrets.PROD_ENV_SECRET }}' > "$TEMP_DIR/env_vars"
            printf '%s' '${{ secrets.PROD_SSH_PRIVATE_KEY }}' > "$TEMP_DIR/ssh_key"
            
          else
            # Development environment
            echo "DEPLOY_PATH=${{ secrets.DEV_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.DEV_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.DEV_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.DEV_SSH_PORT }}" >> $GITHUB_ENV
            echo "PORT_APP=5001" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.DEV_PROCESS_NAME}}" >> $GITHUB_ENV
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
            
            # Handle multiline secrets safely
            printf '%s' '${{ secrets.DEV_ENV_SECRET }}' > "$TEMP_DIR/env_vars"
            printf '%s' '${{ secrets.DEV_SSH_PRIVATE_KEY }}' > "$TEMP_DIR/ssh_key"
          fi
          
          echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> $GITHUB_ENV
          echo "PACKAGE_HASH=$PACKAGE_HASH" >> $GITHUB_ENV
          echo "TEMP_DIR=$TEMP_DIR" >> $GITHUB_ENV
          
          # Set secure permissions
          chmod 600 "$TEMP_DIR/env_vars" "$TEMP_DIR/ssh_key"
          
          echo "‚úÖ Environment configured for $BRANCH"

      - name: üîê Setup SSH
        run: |
          mkdir -p ~/.ssh
          
          # Clean and validate SSH key
          echo "üîß Setting up SSH key..."
          
          # Write SSH key with proper formatting
          cat > ~/.ssh/deploy_key << 'SSH_KEY_EOF'
          ${{ secrets.PROD_SSH_PRIVATE_KEY }}
          SSH_KEY_EOF
          
          # Ensure proper line endings and format
          sed -i 's/\r$//' ~/.ssh/deploy_key
          
          # Set strict permissions
          chmod 600 ~/.ssh/deploy_key
          chmod 700 ~/.ssh
          
          # Create SSH config with better settings
          cat > ~/.ssh/config << EOF
          Host deploy
            HostName $SERVER
            User $USER
            Port $PORT_SSH
            IdentityFile ~/.ssh/deploy_key
            IdentitiesOnly yes
            StrictHostKeyChecking no
            ServerAliveInterval 30
            ConnectTimeout 10
            PreferredAuthentications publickey
            PubkeyAuthentication yes
            PasswordAuthentication no
          EOF
          
          chmod 600 ~/.ssh/config
          
          # Test SSH connection
          echo "üîç Testing SSH connection..."
          if ssh -o ConnectTimeout=10 deploy "echo 'SSH connection successful'"; then
            echo "‚úÖ SSH connection verified"
          else
            echo "‚ùå SSH connection failed"
            exit 1
          fi

      - name: üöÄ True Zero-Downtime Deploy
        run: |
          # Create deployment package
          cd dist
          tar -czf ../app.tar.gz .
          cd ..
          
          # Deploy with optimized zero-downtime script
          ssh deploy << 'DEPLOY_SCRIPT'
            set -e
            
            # Setup paths
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            RELEASE_PATH="$DEPLOY_PATH/releases/${{ env.DEPLOYMENT_ID }}"
            CURRENT_PATH="$DEPLOY_PATH/current"
            SHARED_PATH="$DEPLOY_PATH/shared"
            
            # Create directory structure
            mkdir -p "$RELEASE_PATH" "$SHARED_PATH/logs" "$SHARED_PATH/node_modules"
            
            # Get current package hash if available
            CURRENT_HASH=""
            if [ -L "$CURRENT_PATH" ] && [ -f "$CURRENT_PATH/deployment-info.json" ]; then
              CURRENT_HASH=$(grep -o '"package_hash":"[^"]*"' "$CURRENT_PATH/deployment-info.json" | cut -d'"' -f4)
            fi
            
            # Check if we need to reinstall dependencies
            SHOULD_INSTALL=true
            if [ "$CURRENT_HASH" = "${{ env.PACKAGE_HASH }}" ]; then
              echo "üì¶ Package.json unchanged, will reuse node_modules"
              SHOULD_INSTALL=false
            else
              echo "üì¶ Package.json changed, will reinstall dependencies"
            fi
            
            echo "üèóÔ∏è Setting up release directory..."
          DEPLOY_SCRIPT
          
          # Upload and extract
          echo "üì§ Uploading package..."
          scp app.tar.gz deploy:${{ env.DEPLOY_PATH }}/releases/${{ env.DEPLOYMENT_ID }}/
          
          # Continue deployment
          ssh deploy << 'DEPLOY_SCRIPT'
            set -e
            
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            RELEASE_PATH="$DEPLOY_PATH/releases/${{ env.DEPLOYMENT_ID }}"
            CURRENT_PATH="$DEPLOY_PATH/current"
            SHARED_PATH="$DEPLOY_PATH/shared"
            APP_PATH="$RELEASE_PATH"
            
            cd "$RELEASE_PATH"
            
            echo "üì¶ Extracting package..."
            tar -xzf app.tar.gz && rm app.tar.gz
            
            # Add PORT to environment file
            echo "PORT=${{ env.PORT_APP }}" >> "$APP_PATH/.env.production"
            echo "NODE_ENV=production" >> "$APP_PATH/.env.production"
            
            # Create optimized PM2 ecosystem for Pages Router
            cat > "$RELEASE_PATH/ecosystem.config.js" << EOF
          module.exports = {
            apps: [{
              name: '${{ env.PROCESS_NAME }}',
              script: 'node_modules/.bin/next',
              args: 'start',
              cwd: '$APP_PATH',
              instances: 1,
              exec_mode: 'cluster',
              env: {
                NODE_ENV: 'production',
                PORT: '${{ env.PORT_APP }}',
                PWD: '$APP_PATH',
                NEXT_TELEMETRY_DISABLED: '1'
              },
              max_memory_restart: '512M',
              min_uptime: '15s',
              max_restarts: 5,
              autorestart: true,
              watch: false,
              kill_timeout: 8000,
              wait_ready: true,
              listen_timeout: 20000,
              error_file: '$SHARED_PATH/logs/${{ env.PROCESS_NAME }}-error.log',
              out_file: '$SHARED_PATH/logs/${{ env.PROCESS_NAME }}-out.log',
              log_file: '$SHARED_PATH/logs/${{ env.PROCESS_NAME }}.log',
              time: true,
              merge_logs: true,
              source_map_support: true
            }]
          };
          EOF
            
            # Enhanced health check for Pages Router
            health_check() {
              local attempts=0
              local max_attempts=30
              local port=${{ env.PORT_APP }}
              
              echo "üîç Starting health check on port $port..."
              
              while [ $attempts -lt $max_attempts ]; do
                # Check if port is listening
                if netstat -tuln | grep ":$port " > /dev/null 2>&1; then
                  # Check if API responds
                  if curl -f -s --max-time 3 "http://localhost:$port/api/health" > /dev/null 2>&1; then
                    echo "‚úÖ Health check passed (API responding)"
                    return 0
                  elif curl -f -s --max-time 3 "http://localhost:$port" > /dev/null 2>&1; then
                    echo "‚úÖ Health check passed (home page responding)"
                    return 0
                  else
                    echo "‚ö†Ô∏è Port listening but application not responding yet..."
                  fi
                else
                  echo "‚è≥ Port $port not ready yet..."
                fi
                
                attempts=$((attempts + 1))
                echo "üîÑ Attempt $attempts/$max_attempts..."
                sleep 2
              done
              
              echo "‚ùå Health check failed after $max_attempts attempts"
              return 1
            }
            
            # Backup current if exists
            BACKUP_PATH=""
            if [ -L "$CURRENT_PATH" ]; then
              BACKUP_PATH=$(readlink "$CURRENT_PATH")
              echo "üíæ Backup: $BACKUP_PATH"
            fi
            
            # Install dependencies only if needed
            if [ "$SHOULD_INSTALL" = true ]; then
              echo "üì¶ Installing production dependencies..."
              cd "$RELEASE_PATH"
              npm ci --omit=dev --prefer-offline --no-audit --progress=false
            else
              echo "üì¶ Reusing node_modules from current deployment..."
              if [ -d "$CURRENT_PATH/node_modules" ]; then
                cp -r "$CURRENT_PATH/node_modules" "$RELEASE_PATH/"
              fi
            fi
            
            # Use a temporary process name for the new version
            TMP_PROCESS_NAME="${{ env.PROCESS_NAME }}-new"
            
            # Create temporary ecosystem file for new version
            cat > "$RELEASE_PATH/tmp-ecosystem.config.js" << EOF
          module.exports = {
            apps: [{
              name: '$TMP_PROCESS_NAME',
              script: 'node_modules/.bin/next',
              args: 'start',
              cwd: '$APP_PATH',
              instances: 1,
              exec_mode: 'cluster',
              env: {
                NODE_ENV: 'production',
                PORT: '${{ env.PORT_APP }}',
                PWD: '$APP_PATH',
                NEXT_TELEMETRY_DISABLED: '1'
              },
              max_memory_restart: '512M',
              min_uptime: '15s',
              max_restarts: 5,
              autorestart: true,
              watch: false,
              kill_timeout: 8000,
              wait_ready: true,
              listen_timeout: 20000,
              error_file: '$SHARED_PATH/logs/$TMP_PROCESS_NAME-error.log',
              out_file: '$SHARED_PATH/logs/$TMP_PROCESS_NAME-out.log',
              log_file: '$SHARED_PATH/logs/$TMP_PROCESS_NAME.log',
              time: true,
              merge_logs: true,
              source_map_support: true
            }]
          };
          EOF
            
            # Check if old process is running
            OLD_RUNNING=false
            if pm2 describe ${{ env.PROCESS_NAME }} > /dev/null 2>&1; then
              OLD_RUNNING=true
            fi
            
            # Start the new process
            echo "üöÄ Starting new application version..."
            cd "$RELEASE_PATH"
            pm2 start tmp-ecosystem.config.js
            
            # Wait for process to initialize
            echo "‚è≥ Waiting for new application to start..."
            sleep 3
            
            # Check if new application is healthy
            if health_check; then
              echo "‚úÖ New application is healthy"
              
              # Switch the symlink BEFORE stopping old process
              echo "üîÑ Switching to new release..."
              ln -snf "$RELEASE_PATH" "$CURRENT_PATH"
              
              # Stop the old process if it exists
              if [ "$OLD_RUNNING" = true ]; then
                echo "üõë Gracefully stopping old process..."
                pm2 stop ${{ env.PROCESS_NAME }} || true
                sleep 2
                pm2 delete ${{ env.PROCESS_NAME }} || true
              fi
              
              # Rename the new process to the standard name
              echo "üîÑ Renaming process..."
              pm2 stop $TMP_PROCESS_NAME
              pm2 delete $TMP_PROCESS_NAME
              
              # Start with the correct name
              cd "$CURRENT_PATH"
              pm2 start ecosystem.config.js
              pm2 save
              
              echo "üéâ True zero-downtime deployment successful!"
              
              # Cleanup old releases (keep 3)
              echo "üßπ Cleaning up old releases..."
              cd "$DEPLOY_PATH/releases"
              ls -t | tail -n +4 | xargs -r rm -rf
              
              echo "üìä Final PM2 status:"
              pm2 status ${{ env.PROCESS_NAME }}
              
            else
              echo "‚ùå New application failed health check, aborting deployment"
              
              # Clean up the failed deployment
              pm2 stop $TMP_PROCESS_NAME || true
              pm2 delete $TMP_PROCESS_NAME || true
              
              echo "‚ö†Ô∏è Keeping current version active"
              exit 1
            fi
          DEPLOY_SCRIPT

      - name: üîç Verify Deployment
        run: |
          ssh deploy << 'VERIFY_SCRIPT'
            echo "üìä PM2 Status:"
            pm2 status ${{ env.PROCESS_NAME }}
            
            echo ""
            echo "üåê Application Status:"
            if curl -f -s --max-time 5 http://localhost:${{ env.PORT_APP }}/api/health > /dev/null; then
              echo "‚úÖ Application is responding correctly"
              curl -s http://localhost:${{ env.PORT_APP }}/api/health
            else
              echo "‚ùå Application is not responding"
              echo "üîç Recent logs:"
              pm2 logs ${{ env.PROCESS_NAME }} --lines 5
            fi
            
            echo ""
            echo "üìã Deployment Info:"
            cat ${{ env.DEPLOY_PATH }}/current/deployment-info.json 2>/dev/null || echo "No deployment info available"
            
            echo ""
            echo "üîó Symlink Check:"
            ls -la ${{ env.DEPLOY_PATH }}/current
            readlink -f ${{ env.DEPLOY_PATH }}/current
          VERIFY_SCRIPT

      - name: üßπ Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key 2>/dev/null || true
          rm -f app.tar.gz 2>/dev/null || true
          if [ -n "$TEMP_DIR" ] && [ -d "$TEMP_DIR" ]; then
            rm -rf "$TEMP_DIR"
          fi
          echo "‚úÖ Cleanup completed"

  notify:
    needs: [build, deploy]
    runs-on: self-hosted
    if: always()
    steps:
      - name: üì¢ Deployment Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "üéâ Deployment successful!"
            echo "üÜî ID: ${{ needs.build.outputs.deployment-id }}"
            echo "üåç Environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}"
          else
            echo "‚ùå Deployment failed!"
            echo "üÜî ID: ${{ needs.build.outputs.deployment-id }}"
            echo "üîç Check the logs above for details"
          fi
