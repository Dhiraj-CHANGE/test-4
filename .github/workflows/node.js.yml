name: ⚡ Test1 API Lightning Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18'
  CACHE_VERSION: 'v4'  # Bumped for new optimizations

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
      cache-hit: ${{ steps.cache-check.outputs.cache-hit }}
      branch: ${{ steps.branch.outputs.branch }}
    steps:
      - name: 📋 Get Branch & Generate Metadata
        id: meta
        run: |
          BRANCH=${GITHUB_REF##*/}
          DEPLOYMENT_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "🌿 Branch: $BRANCH | 🆔 ID: $DEPLOYMENT_ID"

      - name: 📋 Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ⚡ Setup Node.js with Cache
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 🔄 Restore Caches
        id: cache-check
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            .next
          key: ${{ env.CACHE_VERSION }}-full-${{ runner.os }}-${{ steps.meta.outputs.branch }}-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx', '**/*.json', '!node_modules/**') }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-full-${{ runner.os }}-${{ steps.meta.outputs.branch }}-${{ hashFiles('**/package-lock.json') }}-
            ${{ env.CACHE_VERSION }}-full-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-

      - name: 🚀 Install & Build (if needed)
        if: steps.cache-check.outputs.cache-hit != 'true'
        run: |
          echo "📦 Installing dependencies..."
          npm ci --prefer-offline --no-audit --no-fund --silent --progress=false
          echo "🏗️ Building application..."
          NODE_ENV=production npm run build
          echo "✅ Build completed"

      - name: 💾 Save Cache
        if: steps.cache-check.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: |
            node_modules
            .next
          key: ${{ steps.cache-check.outputs.cache-primary-key }}

      - name: 📦 Create Ultra-Optimized Package
        run: |
          echo "📦 Creating lightning-fast package..."
          
          # Verify build exists
          [ ! -d ".next" ] && { echo "❌ .next missing!"; exit 1; }
          
          # Ultra-optimized packaging with parallel compression
          echo "🚀 Packaging with maximum optimization..."
          tar -I 'gzip -1' -cf deployment.tar.gz \
            --exclude='node_modules/.cache' \
            --exclude='node_modules/*/test*' \
            --exclude='node_modules/*/docs' \
            --exclude='node_modules/*/examples' \
            --exclude='node_modules/*/*.md' \
            --exclude='node_modules/*/*.txt' \
            --exclude='node_modules/*/LICENSE*' \
            --exclude='node_modules/*/CHANGELOG*' \
            --exclude='.next/cache' \
            --exclude='.next/static/chunks/webpack*' \
            .next \
            node_modules \
            public \
            package.json \
            next.config.*
          
          echo "📊 Package: $(du -sh deployment.tar.gz | cut -f1)"

      - name: 🚀 Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ steps.meta.outputs.deployment-id }}
          path: deployment.tar.gz
          retention-days: 1
          compression-level: 0  # Already compressed

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: 📥 Download & Setup
        run: |
          # Download artifact
          curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/vnd.github.v3+json" \
               -L "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${{ github.repository }}/actions/artifacts" | jq -r '.artifacts[] | select(.name=="app-${{ needs.build.outputs.deployment-id }}") | .id')/zip" \
               -o artifact.zip
          unzip -q artifact.zip
          rm artifact.zip

      - name: ⚙️ Lightning Setup
        id: env-setup
        run: |
          BRANCH="${{ needs.build.outputs.branch }}"
          
          if [ "$BRANCH" = "main" ]; then
            echo "server=${{ secrets.PROD_DOMAIN }}" >> $GITHUB_OUTPUT
            echo "user=${{ secrets.PROD_SERVER_USER }}" >> $GITHUB_OUTPUT
            echo "port=${{ secrets.PROD_SSH_PORT }}" >> $GITHUB_OUTPUT
            echo "deploy-path=${{ secrets.PROD_SERVER_PATH }}" >> $GITHUB_OUTPUT
            echo "process-name=${{ secrets.PROD_PROCESS_NAME }}" >> $GITHUB_OUTPUT
            echo "port-a=${{ secrets.PROD_PORT_A }}" >> $GITHUB_OUTPUT
            echo "port-b=${{ secrets.PROD_PORT_B }}" >> $GITHUB_OUTPUT
            echo "domain=${{ secrets.PROD_DOMAIN }}" >> $GITHUB_OUTPUT
            echo "upstream-name=test1_backend" >> $GITHUB_OUTPUT
            SSH_KEY='${{ secrets.PROD_SSH_PRIVATE_KEY }}'
            ENV_SECRET='${{ secrets.PROD_ENV_SECRET }}'
          else
            echo "server=${{ secrets.DEV_DOMAIN }}" >> $GITHUB_OUTPUT
            echo "user=${{ secrets.DEV_SERVER_USER }}" >> $GITHUB_OUTPUT
            echo "port=${{ secrets.DEV_SSH_PORT }}" >> $GITHUB_OUTPUT
            echo "deploy-path=${{ secrets.DEV_SERVER_PATH }}" >> $GITHUB_OUTPUT
            echo "process-name=${{ secrets.DEV_PROCESS_NAME }}" >> $GITHUB_OUTPUT
            echo "port-a=${{ secrets.DEV_PORT_A }}" >> $GITHUB_OUTPUT
            echo "port-b=${{ secrets.DEV_PORT_B }}" >> $GITHUB_OUTPUT
            echo "domain=${{ secrets.DEV_DOMAIN }}" >> $GITHUB_OUTPUT
            echo "upstream-name=test1_dev_backend" >> $GITHUB_OUTPUT
            SSH_KEY='${{ secrets.DEV_SSH_PRIVATE_KEY }}'
            ENV_SECRET='${{ secrets.DEV_ENV_SECRET }}'
          fi
          
          # Setup SSH in one go
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
          
          cat > ~/.ssh/config << EOF
          Host deploy
            HostName ${{ steps.env-setup.outputs.server }}
            User ${{ steps.env-setup.outputs.user }}
            Port ${{ steps.env-setup.outputs.port }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            ServerAliveInterval 30
            ConnectTimeout 5
            Compression yes
            ControlMaster auto
            ControlPath ~/.ssh/control-%h-%p-%r
            ControlPersist 300
          EOF
          
          # Test connection
          ssh -o ConnectTimeout=5 deploy "echo 'SSH ready'" || exit 1
          
          # Store env secret for later use
          echo "$ENV_SECRET" > .env.secret

      - name: 🚀 Lightning Deploy
        run: |
          DEPLOY_DIR="${{ needs.build.outputs.deployment-id }}"
          DEPLOY_PATH="${{ steps.env-setup.outputs.deploy-path }}"
          UPSTREAM_NAME="${{ steps.env-setup.outputs.upstream-name }}"
          PROCESS_NAME="${{ steps.env-setup.outputs.process-name }}"
          PORT_A="${{ steps.env-setup.outputs.port-a }}"
          PORT_B="${{ steps.env-setup.outputs.port-b }}"
          
          echo "⚡ Lightning deployment: $DEPLOY_DIR"
          
          # Create deployment directory and upload in parallel
          ssh deploy "mkdir -p $DEPLOY_PATH/deployments/$DEPLOY_DIR" &
          
          # Wait for directory creation
          wait
          
          # Upload package and env in parallel
          scp -C deployment.tar.gz deploy:$DEPLOY_PATH/deployments/$DEPLOY_DIR/ &
          scp .env.secret deploy:$DEPLOY_PATH/deployments/$DEPLOY_DIR/.env &
          wait
          
          # Execute optimized deployment script
          ssh deploy << 'EOFSCRIPT'
          set -e
          
          DEPLOY_PATH="__DEPLOY_PATH__"
          DEPLOYMENT_ID="__DEPLOYMENT_ID__"
          UPSTREAM_NAME="__UPSTREAM_NAME__"
          PROCESS_NAME="__PROCESS_NAME__"
          PORT_A="__PORT_A__"
          PORT_B="__PORT_B__"
          
          NEW_PATH="$DEPLOY_PATH/deployments/$DEPLOYMENT_ID"
          cd "$NEW_PATH"
          
          echo "⚡ Extracting..."
          tar -xzf deployment.tar.gz && rm deployment.tar.gz
          
          # Quick validation
          [ ! -f "package.json" ] && exit 1
          [ ! -d ".next" ] && exit 1
          
          # Smart port detection
          CURRENT_PORT=""
          if [ -f "/etc/nginx/conf.d/$UPSTREAM_NAME.conf" ]; then
            CURRENT_PORT=$(grep -o "127.0.0.1:[0-9]*" /etc/nginx/conf.d/$UPSTREAM_NAME.conf | cut -d: -f2 2>/dev/null || echo "")
          fi
          
          # Determine new port
          if [ -z "$CURRENT_PORT" ] || [ "$CURRENT_PORT" = "$PORT_A" ]; then
            NEW_PORT="$PORT_B"
            NEW_PROCESS="$PROCESS_NAME-b"
            OLD_PROCESS="$PROCESS_NAME-a"
          else
            NEW_PORT="$PORT_A"
            NEW_PROCESS="$PROCESS_NAME-a"
            OLD_PROCESS="$PROCESS_NAME-b"
          fi
          
          echo "🔄 $CURRENT_PORT → $NEW_PORT"
          
          # Add env vars
          echo "PORT=$NEW_PORT" >> .env
          echo "NODE_ENV=production" >> .env
          echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> .env
          
          # Create optimized PM2 config
          cat > ecosystem.config.cjs << EOFPM2
          module.exports = {
            apps: [{
              name: '$NEW_PROCESS',
              script: './node_modules/.bin/next',
              args: 'start',
              cwd: '$NEW_PATH',
              instances: 1,
              env: {
                NODE_ENV: 'production',
                PORT: '$NEW_PORT',
                NEXT_TELEMETRY_DISABLED: '1'
              },
              max_memory_restart: '512M',
              min_uptime: '3s',
              max_restarts: 2,
              autorestart: true,
              watch: false,
              kill_timeout: 3000,
              wait_ready: true,
              listen_timeout: 5000,
              error_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-error.log',
              out_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-out.log'
            }]
          };
          EOFPM2
          
          # Start new process
          echo "🚀 Starting $NEW_PROCESS..."
          pm2 start ecosystem.config.cjs
          
          # Fast health check
          echo "🔍 Health check..."
          for i in {1..15}; do
            if curl -f -s --max-time 1 "http://localhost:$NEW_PORT" >/dev/null 2>&1; then
              echo "✅ Health check passed ($i/15)"
              break
            fi
            [ $i -eq 15 ] && { echo "❌ Health check failed"; pm2 delete $NEW_PROCESS; exit 1; }
            sleep 1
          done
          
          # Update Nginx upstream
          echo "🔄 Updating Nginx..."
          sudo tee "/etc/nginx/conf.d/$UPSTREAM_NAME.conf" > /dev/null << EOFNGINX
          upstream $UPSTREAM_NAME {
              server 127.0.0.1:$NEW_PORT;
          }
          EOFNGINX
          
          # Test and reload Nginx
          if sudo nginx -t >/dev/null 2>&1; then
            sudo nginx -s reload
            sleep 1
            
            # Stop old process
            if pm2 describe $OLD_PROCESS >/dev/null 2>&1; then
              echo "🛑 Stopping $OLD_PROCESS"
              pm2 delete $OLD_PROCESS >/dev/null 2>&1 || true
            fi
            
            # Update symlinks
            [ -L "$DEPLOY_PATH/current" ] && rm "$DEPLOY_PATH/current"
            ln -sfn "$NEW_PATH" "$DEPLOY_PATH/current"
            
            # Cleanup old deployments (keep 2)
            cd "$DEPLOY_PATH/deployments" && ls -t | tail -n +3 | xargs -r rm -rf >/dev/null 2>&1 || true
            
            pm2 save >/dev/null 2>&1
            echo "🎉 Deploy complete!"
          else
            echo "❌ Nginx test failed"
            pm2 delete $NEW_PROCESS
            exit 1
          fi
          EOFSCRIPT
          
          # Replace variables in the script
          ssh deploy "cd $DEPLOY_PATH/deployments/$DEPLOY_DIR && sed -i 's|__DEPLOY_PATH__|$DEPLOY_PATH|g; s|__DEPLOYMENT_ID__|$DEPLOY_DIR|g; s|__UPSTREAM_NAME__|$UPSTREAM_NAME|g; s|__PROCESS_NAME__|$PROCESS_NAME|g; s|__PORT_A__|$PORT_A|g; s|__PORT_B__|$PORT_B|g' /dev/stdin" << 'EOFSCRIPT'
          # The script content will be processed here
          EOFSCRIPT

      - name: 🔍 Quick Verify
        run: |
          ssh deploy << VERIFY
            echo "📊 Status: $(pm2 list | grep '${{ steps.env-setup.outputs.process-name }}' | grep -c 'online' || echo '0') processes"
            echo "🌐 Test: $(curl -s -o /dev/null -w '%{http_code}' 'https://${{ steps.env-setup.outputs.domain }}' || echo 'FAIL')"
          VERIFY

      - name: 🧹 Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key deployment.tar.gz .env.secret
          ssh -O exit deploy 2>/dev/null || true

  notify:
    needs: [build, deploy]
    runs-on: self-hosted
    if: always()
    steps:
      - name: 📢 Lightning Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "⚡ Lightning deployment successful!"
            echo "🚀 Cache: ${{ needs.build.outputs.cache-hit == 'true' && 'HIT' || 'MISS' }}"
            echo "🌍 Env: ${{ github.ref == 'refs/heads/main' && 'PROD' || 'DEV' }}"
          else
            echo "❌ Deployment failed!"
          fi