name: âš¡ Test1 API Ultra-Fast Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18'
  CACHE_VERSION: 'v3'

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
      cache-hit: ${{ steps.cache-check.outputs.cache-hit }}
      branch: ${{ steps.branch.outputs.branch }}
    steps:
      - name: ðŸ“‹ Get Branch Name
        id: branch
        run: |
          BRANCH=${GITHUB_REF##*/}
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "ðŸŒ¿ Branch: $BRANCH"

      - name: ðŸ“‹ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ðŸ“Š Generate Metadata
        id: meta
        run: |
          DEPLOYMENT_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "ðŸ†” Deployment ID: $DEPLOYMENT_ID"

      - name: âš¡ Setup Node.js with Cache
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ”„ Cache Dependencies Only
        id: cache-deps
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ env.CACHE_VERSION }}-deps-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-deps-${{ runner.os }}-

      - name: ðŸ”„ Cache Build Output
        id: cache-check
        uses: actions/cache@v3
        with:
          path: .next
          key: ${{ env.CACHE_VERSION }}-build-${{ runner.os }}-${{ steps.branch.outputs.branch }}-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx', '**/*.json', '!node_modules/**') }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-build-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-

      - name: ðŸš€ Install Dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: |
          npm ci --prefer-offline --no-audit --no-fund --silent --progress=false
          echo "ðŸ“¦ Dependencies installed"

      - name: ðŸ—ï¸ Build Application
        if: steps.cache-check.outputs.cache-hit != 'true'
        run: |
          NODE_ENV=production npm run build
          echo "âœ… Build completed"

      - name: ðŸ“¦ Create Optimized Package
        run: |
          echo "ðŸ“¦ Creating optimized package..."
          
          # Verify build exists
          if [ ! -d ".next" ]; then
            echo "âŒ .next directory not found! Build may have failed."
            exit 1
          fi
          
          # Show build info
          echo "ðŸ“Š Build info:"
          echo "  - .next size: $(du -sh .next | cut -f1)"
          echo "  - node_modules size: $(du -sh node_modules | cut -f1)"
          
          tar -czf deployment.tar.gz \
            --exclude='node_modules/.cache' \
            --exclude='node_modules/*/test*' \
            --exclude='node_modules/*/docs' \
            --exclude='node_modules/*/*.md' \
            --exclude='.next/cache' \
            .next \
            node_modules \
            public \
            package.json \
            next.config.*
          echo "ðŸ“¦ Package size: $(du -sh deployment.tar.gz | cut -f1)"

      - name: ðŸš€ Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ steps.meta.outputs.deployment-id }}
          path: deployment.tar.gz
          retention-days: 1
          compression-level: 1

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: ðŸ“¥ Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-${{ needs.build.outputs.deployment-id }}
          path: .

      - name: âš™ï¸ Setup Environment Variables
        id: env-setup
        run: |
          BRANCH="${{ needs.build.outputs.branch }}"
          echo "ðŸŒ¿ Branch: $BRANCH"
          
          if [ "$BRANCH" = "main" ]; then
            # Production environment
            SERVER="${{ secrets.PROD_DOMAIN }}" 
            USER="${{ secrets.PROD_SERVER_USER }}"
            PORT_SSH="${{ secrets.PROD_SSH_PORT }}"
            DEPLOY_PATH="${{ secrets.PROD_SERVER_PATH }}"
            PROCESS_NAME="${{ secrets.PROD_PROCESS_NAME }}"
            PORT_A="${{ secrets.PROD_PORT_A }}"
            PORT_B="${{ secrets.PROD_PORT_B }}"
            DOMAIN="${{ secrets.PROD_DOMAIN }}"
            ENV_SECRET="${{ secrets.PROD_ENV_SECRET }}"
            SSH_KEY="${{ secrets.PROD_SSH_PRIVATE_KEY }}"
            # For production, use the existing upstream name that the site config expects
            UPSTREAM_NAME="test1_backend"
          else
            # Development environment
            SERVER="${{ secrets.DEV_DOMAIN }}"
            USER="${{ secrets.DEV_SERVER_USER }}"
            PORT_SSH="${{ secrets.DEV_SSH_PORT }}"
            DEPLOY_PATH="${{ secrets.DEV_SERVER_PATH }}"
            PROCESS_NAME="${{ secrets.DEV_PROCESS_NAME }}"
            PORT_A="${{ secrets.DEV_PORT_A }}"
            PORT_B="${{ secrets.DEV_PORT_B }}"
            DOMAIN="${{ secrets.DEV_DOMAIN }}"
            ENV_SECRET="${{ secrets.DEV_ENV_SECRET }}"
            SSH_KEY="${{ secrets.DEV_SSH_PRIVATE_KEY }}"
            # For development, use the same upstream name that the site config expects
            UPSTREAM_NAME="test1_dev_backend"
          fi
          
          # Validate required variables
          if [ -z "$SERVER" ]; then
            echo "âŒ SERVER is not set. Please add SERVER_HOST to your repository secrets."
            exit 1
          fi
          
          if [ -z "$USER" ]; then
            echo "âŒ USER is not set. Please add SERVER_USER to your repository secrets."
            exit 1
          fi
          
          if [ -z "$PORT_SSH" ]; then
            echo "âš ï¸ PORT_SSH is not set, defaulting to 22"
            PORT_SSH="22"
          fi
          
          if [ -z "$SSH_KEY" ]; then
            echo "âŒ SSH_KEY is not set. Please add SSH_PRIVATE_KEY to your repository secrets."
            exit 1
          fi
          
          if [ -z "$DEPLOY_PATH" ]; then
            echo "âŒ DEPLOY_PATH is not set. Please add DEPLOY_PATH to your repository secrets."
            exit 1
          fi
          
          # Set outputs for use in later steps
          echo "server=$SERVER" >> $GITHUB_OUTPUT
          echo "user=$USER" >> $GITHUB_OUTPUT
          echo "port=$PORT_SSH" >> $GITHUB_OUTPUT
          echo "deploy-path=$DEPLOY_PATH" >> $GITHUB_OUTPUT
          echo "process-name=$PROCESS_NAME" >> $GITHUB_OUTPUT
          echo "port-a=$PORT_A" >> $GITHUB_OUTPUT
          echo "port-b=$PORT_B" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "upstream-name=$UPSTREAM_NAME" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          
          # Set environment variables for this job
          echo "DEPLOYMENT_ID=${{ needs.build.outputs.deployment-id }}" >> $GITHUB_ENV
          echo "SERVER=$SERVER" >> $GITHUB_ENV
          echo "USER=$USER" >> $GITHUB_ENV
          echo "PORT_SSH=$PORT_SSH" >> $GITHUB_ENV
          echo "DEPLOY_PATH=$DEPLOY_PATH" >> $GITHUB_ENV
          echo "PROCESS_NAME=$PROCESS_NAME" >> $GITHUB_ENV
          echo "PORT_A=$PORT_A" >> $GITHUB_ENV
          echo "PORT_B=$PORT_B" >> $GITHUB_ENV
          echo "DOMAIN=$DOMAIN" >> $GITHUB_ENV
          echo "UPSTREAM_NAME=$UPSTREAM_NAME" >> $GITHUB_ENV

      - name: ðŸ” Setup SSH Configuration
        run: |
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Determine which SSH key to use based on branch
          BRANCH="${{ needs.build.outputs.branch }}"
          if [ "$BRANCH" = "main" ]; then
            SSH_KEY='${{ secrets.PROD_SSH_PRIVATE_KEY }}'
          else
            SSH_KEY='${{ secrets.DEV_SSH_PRIVATE_KEY }}'
          fi
          
          # Write SSH private key
          echo "$SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify SSH key format
          if ! ssh-keygen -l -f ~/.ssh/deploy_key >/dev/null 2>&1; then
            echo "âŒ Invalid SSH key format"
            exit 1
          fi
          
          # Validate server hostname
          if [ -z "${{ steps.env-setup.outputs.server }}" ]; then
            echo "âŒ Server hostname is empty. Please check your repository secrets."
            exit 1
          fi
          
          # Create SSH config with validated hostname
          cat > ~/.ssh/config << EOF
          Host deploy
            HostName ${{ steps.env-setup.outputs.server }}
            User ${{ steps.env-setup.outputs.user }}
            Port ${{ steps.env-setup.outputs.port }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            ServerAliveInterval 30
            ConnectTimeout 10
            Compression yes
          EOF
          
          # Test SSH connection
          echo "ðŸ” Testing SSH connection to ${{ steps.env-setup.outputs.server }}..."
          if ssh -o BatchMode=yes -o ConnectTimeout=10 deploy "echo 'SSH connection successful'"; then
            echo "âœ… SSH connection test passed"
          else
            echo "âŒ SSH connection test failed"
            exit 1
          fi

      - name: ðŸ§¹ Clean Old Deployments First
        run: |
          echo "ðŸ§¹ Cleaning old deployments (keeping only 2 most recent)..."
          ssh deploy "mkdir -p ${{ steps.env-setup.outputs.deploy-path }}/deployments && cd ${{ steps.env-setup.outputs.deploy-path }}/deployments && ls -t | tail -n +3 | xargs -r rm -rf || echo 'No old deployments to clean'"

      - name: ðŸš€ Deploy Application
        run: |
          # Define variables locally first
          DEPLOY_DIR="${{ env.DEPLOYMENT_ID }}"
          BRANCH="${{ needs.build.outputs.branch }}"
          UPSTREAM_NAME="$UPSTREAM_NAME"
          DEPLOY_PATH="$DEPLOY_PATH"
          PROCESS_NAME="$PROCESS_NAME"
          PORT_A="$PORT_A"
          PORT_B="$PORT_B"
          
          # Verify all required variables are set
          echo "ðŸ” Verifying deployment variables..."
          echo "  - DEPLOY_DIR: $DEPLOY_DIR"
          echo "  - BRANCH: $BRANCH"
          echo "  - UPSTREAM_NAME: $UPSTREAM_NAME"
          echo "  - DEPLOY_PATH: $DEPLOY_PATH"
          echo "  - PROCESS_NAME: $PROCESS_NAME"
          echo "  - PORT_A: $PORT_A"
          echo "  - PORT_B: $PORT_B"
          
          if [ -z "$DEPLOY_PATH" ]; then
            echo "âŒ DEPLOY_PATH is empty! Cannot proceed with deployment."
            exit 1
          fi
          
          echo "ðŸ“¤ Creating deployment directory: $DEPLOY_DIR"
          ssh deploy "mkdir -p $DEPLOY_PATH/deployments/$DEPLOY_DIR"
          
          echo "ðŸ“¤ Uploading deployment package..."
          scp -C deployment.tar.gz deploy:$DEPLOY_PATH/deployments/$DEPLOY_DIR/deployment.tar.gz
          
          # Copy environment variables based on branch
          if [ "$BRANCH" = "main" ]; then
            echo '${{ secrets.PROD_ENV_SECRET }}' | ssh deploy "cat > $DEPLOY_PATH/deployments/$DEPLOY_DIR/.env"
          else
            echo '${{ secrets.DEV_ENV_SECRET }}' | ssh deploy "cat > $DEPLOY_PATH/deployments/$DEPLOY_DIR/.env"
          fi