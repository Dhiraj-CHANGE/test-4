name: ‚ö° Fast Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18'

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
      cache-key: ${{ steps.meta.outputs.cache-key }}
    steps:
      - name: üìã Checkout
        uses: actions/checkout@v4

      - name: üìä Generate Metadata
        id: meta
        run: |
          DEPLOYMENT_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}"
          CACHE_KEY="build-${{ runner.os }}-node${{ env.NODE_VERSION }}-${{ hashFiles('package-lock.json') }}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT
          echo "üÜî Deployment ID: $DEPLOYMENT_ID"

      - name: ‚ö° Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì¶ Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            node_modules
            .next/cache
          key: ${{ steps.meta.outputs.cache-key }}
          restore-keys: |
            build-${{ runner.os }}-node${{ env.NODE_VERSION }}-

      - name: üîß Install Dependencies
        run: |
          npm ci --prefer-offline --no-audit --progress=false
          echo "‚úÖ Dependencies installed"

      - name: üèóÔ∏è Build Application
        run: |
          npm run build
          echo "‚úÖ Build completed"

      - name: üì¶ Create Optimized Package
        run: |
          # Create minimal production package
          mkdir -p dist
          
          # Copy Next.js build output for Pages Router
          cp -r .next dist/
          cp -r pages dist/ 2>/dev/null || echo "No pages directory found"
          cp -r public dist/ 2>/dev/null || echo "No public directory found"
          cp package.json package-lock.json dist/
          
          # Copy other essential directories for Pages Router
          [ -d "styles" ] && cp -r styles dist/ || echo "No styles directory"
          [ -d "components" ] && cp -r components dist/ || echo "No components directory"
          [ -d "lib" ] && cp -r lib dist/ || echo "No lib directory"
          [ -d "utils" ] && cp -r utils dist/ || echo "No utils directory"
          [ -d "hooks" ] && cp -r hooks dist/ || echo "No hooks directory"
          
          # Copy Next.js config if it exists
          [ -f "next.config.js" ] && cp next.config.js dist/ || echo "No next.config.js"
          [ -f "next.config.mjs" ] && cp next.config.mjs dist/ || echo "No next.config.mjs"
          
          # Create minimal package.json for Pages Router
          node -e "
            const pkg = require('./package.json');
            const minimal = {
              name: pkg.name,
              version: pkg.version,
              scripts: { 
                start: 'next start',
                build: 'next build'
              },
              dependencies: pkg.dependencies
            };
            require('fs').writeFileSync('dist/package.json', JSON.stringify(minimal, null, 2));
          "
          
          # Install only production deps
          cd dist && npm ci --production --prefer-offline --no-audit --progress=false
          
          # Create deployment manifest
          cat > deployment.json << EOF
          {
            "id": "${{ steps.meta.outputs.deployment-id }}",
            "branch": "${GITHUB_REF##*/}",
            "commit": "${GITHUB_SHA}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "size": "$(du -sh dist | cut -f1)",
            "router": "pages"
          }
          EOF
          
          echo "üì¶ Package size: $(du -sh dist | cut -f1)"

      - name: üöÄ Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ steps.meta.outputs.deployment-id }}
          path: |
            dist
            deployment.json
          retention-days: 1
          compression-level: 6

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: üì• Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-${{ needs.build.outputs.deployment-id }}

      - name: ‚öôÔ∏è Setup Environment
        id: env
        run: |
          BRANCH=${GITHUB_REF##*/}
          
          if [ "$BRANCH" = "main" ]; then
            cat >> $GITHUB_ENV << EOF
          DEPLOY_PATH=/var/www/test-4
          SERVER=${{ secrets.PROD_SERVER_HOST }}
          USER=${{ secrets.PROD_SERVER_USER }}
          PORT_SSH=${{ secrets.PROD_SSH_PORT }}
          PORT_APP=5005
          PROCESS_NAME=test-4-prod
          ENV_VARS=${{ secrets.PROD_ENV_SECRET }}
          SSH_KEY=${{ secrets.PROD_SSH_PRIVATE_KEY }}
          EOF
          else
            cat >> $GITHUB_ENV << EOF
          DEPLOY_PATH=/var/www/test-4-dev
          SERVER=${{ secrets.DEV_SERVER_HOST }}
          USER=${{ secrets.DEV_SERVER_USER }}
          PORT_SSH=${{ secrets.DEV_SSH_PORT }}
          PORT_APP=5001
          PROCESS_NAME=test-4-dev
          ENV_VARS=${{ secrets.DEV_ENV_SECRET }}
          SSH_KEY=${{ secrets.DEV_SSH_PRIVATE_KEY }}
          EOF
          fi
          
          echo "DEPLOYMENT_ID=${{ needs.build.outputs.deployment-id }}" >> $GITHUB_ENV

      - name: üîê Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          cat > ~/.ssh/config << EOF
          Host deploy
            HostName $SERVER
            User $USER
            Port $PORT_SSH
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            ServerAliveInterval 30
            ConnectTimeout 10
          EOF

      - name: üöÄ Lightning Deploy
        run: |
          # Create deployment package
          tar -czf app.tar.gz dist deployment.json
          
          # Deploy with optimized script
          ssh deploy << 'DEPLOY_SCRIPT'
            set -e
            
            # Setup paths
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            RELEASE_PATH="$DEPLOY_PATH/releases/${{ env.DEPLOYMENT_ID }}"
            CURRENT_PATH="$DEPLOY_PATH/current"
            
            echo "üèóÔ∏è Setting up release directory..."
            mkdir -p "$RELEASE_PATH" "$DEPLOY_PATH/shared/logs"
            
          DEPLOY_SCRIPT
          
          # Upload and extract
          echo "üì§ Uploading package..."
          scp app.tar.gz deploy:${{ env.DEPLOY_PATH }}/releases/${{ env.DEPLOYMENT_ID }}/
          
          # Continue deployment
          ssh deploy << 'DEPLOY_SCRIPT'
            set -e
            
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            RELEASE_PATH="$DEPLOY_PATH/releases/${{ env.DEPLOYMENT_ID }}"
            CURRENT_PATH="$DEPLOY_PATH/current"
            APP_PATH="$RELEASE_PATH/dist"
            
            cd "$RELEASE_PATH"
            
            echo "üì¶ Extracting package..."
            tar -xzf app.tar.gz && rm app.tar.gz
            
            # Create environment file
            cat > "$APP_PATH/.env.production" << 'ENV_EOF'
          ${{ env.ENV_VARS }}
          PORT=${{ env.PORT_APP }}
          NODE_ENV=production
          ENV_EOF
            
            # Create optimized PM2 ecosystem with absolute paths
            cat > "$RELEASE_PATH/ecosystem.config.js" << EOF
          module.exports = {
            apps: [{
              name: '${{ env.PROCESS_NAME }}',
              script: '$APP_PATH/node_modules/.bin/next',
              args: 'start',
              cwd: '$APP_PATH',
              instances: 1,
              exec_mode: 'cluster',
              env: {
                NODE_ENV: 'production',
                PORT: '${{ env.PORT_APP }}',
                PWD: '$APP_PATH'
              },
              max_memory_restart: '512M',
              min_uptime: '10s',
              max_restarts: 5,
              autorestart: true,
              watch: false,
              kill_timeout: 5000,
              wait_ready: true,
              listen_timeout: 10000,
              error_file: '$DEPLOY_PATH/shared/logs/${{ env.PROCESS_NAME }}-error.log',
              out_file: '$DEPLOY_PATH/shared/logs/${{ env.PROCESS_NAME }}-out.log',
              log_file: '$DEPLOY_PATH/shared/logs/${{ env.PROCESS_NAME }}.log',
              time: true,
              merge_logs: true
            }]
          };
          EOF
            
            # Enhanced health check function
            health_check() {
              local attempts=0
              local max_attempts=30
              local port=${{ env.PORT_APP }}
              
              echo "üîç Starting health check on port $port..."
              
              while [ $attempts -lt $max_attempts ]; do
                # Check if port is listening
                if netstat -tuln | grep ":$port " > /dev/null 2>&1; then
                  # Check if application responds
                  if curl -f -s --max-time 5 "http://localhost:$port" > /dev/null 2>&1; then
                    echo "‚úÖ Health check passed (port listening and responding)"
                    return 0
                  else
                    echo "‚ö†Ô∏è Port listening but app not responding yet..."
                  fi
                else
                  echo "‚è≥ Port $port not ready yet..."
                fi
                
                attempts=$((attempts + 1))
                echo "üîÑ Attempt $attempts/$max_attempts..."
                sleep 3
              done
              
              echo "‚ùå Health check failed after $max_attempts attempts"
              echo "üîç Checking PM2 logs..."
              pm2 logs ${{ env.PROCESS_NAME }} --lines 10 || true
              return 1
            }
            
            # Backup current if exists
            BACKUP_PATH=""
            if [ -L "$CURRENT_PATH" ]; then
              BACKUP_PATH=$(readlink "$CURRENT_PATH")
              echo "üíæ Backup: $BACKUP_PATH"
            fi
            
            # Stop existing process if running
            if pm2 describe ${{ env.PROCESS_NAME }} > /dev/null 2>&1; then
              echo "üõë Stopping existing process..."
              pm2 stop ${{ env.PROCESS_NAME }}
              sleep 2
            fi
            
            # Atomic switch
            echo "üîÑ Switching to new release..."
            ln -snf "$RELEASE_PATH" "$CURRENT_PATH"
            
            # Start PM2 process
            cd "$CURRENT_PATH"
            echo "üöÄ Starting PM2 process..."
            pm2 start ecosystem.config.js
            
            # Wait for process to initialize
            echo "‚è≥ Waiting for application to start..."
            sleep 5
            
            if health_check; then
              echo "üéâ Deployment successful!"
              pm2 save
              
              # Cleanup old releases (keep 3)
              echo "üßπ Cleaning up old releases..."
              cd "$DEPLOY_PATH/releases"
              ls -t | tail -n +4 | xargs -r rm -rf
              
              echo "üìä Final PM2 status:"
              pm2 status ${{ env.PROCESS_NAME }}
              
            else
              echo "‚ùå Deployment failed, attempting rollback..."
              
              # Stop failed process
              pm2 stop ${{ env.PROCESS_NAME }} || true
              pm2 delete ${{ env.PROCESS_NAME }} || true
              
              if [ -n "$BACKUP_PATH" ] && [ -d "$BACKUP_PATH" ]; then
                echo "üîÑ Rolling back to: $BACKUP_PATH"
                ln -snf "$BACKUP_PATH" "$CURRENT_PATH"
                cd "$CURRENT_PATH"
                pm2 start ecosystem.config.js
                echo "‚úÖ Rollback completed"
              else
                echo "‚ö†Ô∏è No backup available"
              fi
              
              exit 1
            fi
          DEPLOY_SCRIPT

      - name: üîç Verify Deployment
        run: |
          ssh deploy << 'VERIFY_SCRIPT'
            echo "üìä PM2 Status:"
            pm2 status ${{ env.PROCESS_NAME }}
            
            echo ""
            echo "üåê Application Status:"
            if curl -f -s --max-time 5 http://localhost:${{ env.PORT_APP }} > /dev/null; then
              echo "‚úÖ Application is responding correctly"
            else
              echo "‚ùå Application is not responding"
              echo "üîç Recent logs:"
              pm2 logs ${{ env.PROCESS_NAME }} --lines 5
            fi
            
            echo ""
            echo "üìã Deployment Info:"
            cat ${{ env.DEPLOY_PATH }}/current/deployment.json 2>/dev/null || echo "No deployment info available"
            
            echo ""
            echo "üíæ Disk Usage:"
            du -sh ${{ env.DEPLOY_PATH }}/releases/* 2>/dev/null | tail -3 || echo "No releases found"
          VERIFY_SCRIPT

      - name: üßπ Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key app.tar.gz 2>/dev/null || true

  notify:
    needs: [build, deploy]
    runs-on: self-hosted
    if: always()
    steps:
      - name: üì¢ Deployment Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "üéâ Deployment successful!"
            echo "üÜî ID: ${{ needs.build.outputs.deployment-id }}"
            echo "üåç Environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}"
            echo "‚è±Ô∏è Total time: ${{ github.event.head_commit.timestamp }}"
          else
            echo "‚ùå Deployment failed!"
            echo "üÜî ID: ${{ needs.build.outputs.deployment-id }}"
            echo "üîç Check the logs above for details"
          fi
