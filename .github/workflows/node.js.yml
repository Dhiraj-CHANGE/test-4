name: ⚡ Test1 API Ultra-Fast Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18'
  CACHE_VERSION: 'v1'

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
      cache-hit: ${{ steps.cache-check.outputs.cache-hit }}
      build-hash: ${{ steps.build-hash.outputs.hash }}
    steps:
      - name: 📋 Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 📊 Generate Metadata
        id: meta
        run: |
          DEPLOYMENT_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "🆔 Deployment ID: $DEPLOYMENT_ID"

      - name: 🔍 Generate Build Hash
        id: build-hash
        run: |
          # Create hash from all build-affecting files
          BUILD_HASH=$(find . -name "package*.json" -o -name "*.config.*" -o -name "tsconfig.json" | sort | xargs cat | sha256sum | cut -d' ' -f1)
          echo "hash=$BUILD_HASH" >> $GITHUB_OUTPUT
          echo "📦 Build Hash: $BUILD_HASH"

      - name: ⚡ Setup Node.js with Cache
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 🔄 Cache Build Output
        id: cache-check
        uses: actions/cache@v3
        with:
          path: |
            .next
            node_modules
          key: ${{ env.CACHE_VERSION }}-build-${{ runner.os }}-${{ steps.build-hash.outputs.hash }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-build-${{ runner.os }}-

      - name: 🚀 Fast Install Dependencies
        if: steps.cache-check.outputs.cache-hit != 'true'
        run: |
          # Ultra-fast dependency installation
          npm ci --prefer-offline --no-audit --no-fund --silent --progress=false
          echo "📦 Dependencies installed"

      - name: 🏗️ Build Application
        if: steps.cache-check.outputs.cache-hit != 'true'
        run: |
          # Build with optimizations
          NODE_ENV=production npm run build
          echo "✅ Build completed"

      - name: 📦 Create Optimized Package
        run: |
          # Create minimal deployment package
          echo "📦 Creating optimized package..."
          
          # Only include essential runtime files
          tar -czf deployment.tar.gz \
            --exclude='node_modules/.cache' \
            --exclude='node_modules/*/test*' \
            --exclude='node_modules/*/docs' \
            --exclude='node_modules/*/*.md' \
            --exclude='.next/cache' \
            .next \
            node_modules \
            public \
            package.json \
            next.config.*
          
          echo "📦 Package size: $(du -sh deployment.tar.gz | cut -f1)"

      - name: 🚀 Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ steps.meta.outputs.deployment-id }}
          path: deployment.tar.gz
          retention-days: 1
          compression-level: 1

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: 📥 Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-${{ needs.build.outputs.deployment-id }}
          path: .

      - name: ⚙️ Setup Environment
        run: |
          BRANCH=${GITHUB_REF##*/}
          
          if [ "$BRANCH" = "main" ]; then
            echo "DEPLOY_PATH=${{ secrets.PROD_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.PROD_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.PROD_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.PROD_SSH_PORT }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.PROD_PROCESS_NAME}}" >> $GITHUB_ENV
            echo "PORT_A=${{ secrets.PROD_PORT_A}}" >> $GITHUB_ENV
            echo "PORT_B=${{ secrets.PROD_PORT_B}}" >> $GITHUB_ENV
            echo "DOMAIN=${{ secrets.PROD_DOMAIN}}" >> $GITHUB_ENV
          else
            echo "DEPLOY_PATH=${{ secrets.DEV_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.DEV_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.DEV_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.DEV_SSH_PORT }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.DEV_PROCESS_NAME}}" >> $GITHUB_ENV
            echo "PORT_A=${{ secrets.DEV_PORT_A}}" >> $GITHUB_ENV
            echo "PORT_B=${{ secrets.DEV_PORT_B}}" >> $GITHUB_ENV
            echo "DOMAIN=${{ secrets.DEV_DOMAIN}}" >> $GITHUB_ENV
          fi
          
          echo "DEPLOYMENT_ID=${{ needs.build.outputs.deployment-id }}" >> $GITHUB_ENV

      - name: 🔐 Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo '${{ secrets.PROD_SSH_PRIVATE_KEY }}' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          cat > ~/.ssh/config << EOF
          Host deploy
            HostName $SERVER
            User $USER
            Port $PORT_SSH
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            ServerAliveInterval 30
            ConnectTimeout 5
            Compression yes
          EOF

      - name: 🚀 Ultra-Fast Zero-Downtime Deploy
        run: |
          DEPLOY_DIR="${{ env.DEPLOYMENT_ID }}"
          
          # Parallel upload and setup
          ssh deploy "mkdir -p ${{ env.DEPLOY_PATH }}/deployments/$DEPLOY_DIR" &
          SETUP_PID=$!
          
          # Upload while setup is running
          scp -C deployment.tar.gz deploy:${{ env.DEPLOY_PATH }}/deployments/$DEPLOY_DIR/deployment.tar.gz &
          UPLOAD_PID=$!
          
          # Wait for both to complete
          wait $SETUP_PID $UPLOAD_PID
          
          # Copy environment variables
          echo '${{ secrets.PROD_ENV_SECRET }}' | ssh deploy "cat > ${{ env.DEPLOY_PATH }}/deployments/$DEPLOY_DIR/.env"
          
          # Execute optimized deployment
          ssh deploy << 'DEPLOY_SCRIPT'
            set -e
            
            # Setup paths
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            DEPLOYMENT_ID="${{ env.DEPLOYMENT_ID }}"
            NEW_DEPLOYMENT_PATH="$DEPLOY_PATH/deployments/$DEPLOYMENT_ID"
            CURRENT_PATH="$DEPLOY_PATH/current"
            STAGING_PATH="$DEPLOY_PATH/staging"
            
            # Create directories
            mkdir -p "$NEW_DEPLOYMENT_PATH" "$CURRENT_PATH" "$STAGING_PATH" "$DEPLOY_PATH/logs"
            
            cd "$NEW_DEPLOYMENT_PATH"
            
            # Fast extraction
            echo "📦 Extracting package..."
            tar -xzf deployment.tar.gz && rm deployment.tar.gz
            
            # Verify critical files
            [ ! -f "package.json" ] && { echo "❌ package.json missing"; exit 1; }
            [ ! -d ".next" ] && { echo "❌ .next missing"; exit 1; }
            
            # Detect if this is first deployment
            FIRST_DEPLOYMENT=false
            if ! pm2 list | grep -q "${{ env.PROCESS_NAME }}" && [ ! -f "/etc/nginx/conf.d/test1_backend.conf" ]; then
              FIRST_DEPLOYMENT=true
              echo "🎯 First deployment detected"
            fi
            
            # Get current port or set default for first deployment
            if [ "$FIRST_DEPLOYMENT" = true ]; then
              CURRENT_PORT=""
              NEW_PORT="${{ env.PORT_A }}"
              NEW_PROCESS="${{ env.PROCESS_NAME }}-a"
              OLD_PROCESS=""
              echo "🚀 First deployment: Using port $NEW_PORT"
            else
              CURRENT_PORT=$(grep -o "127.0.0.1:[0-9]*" /etc/nginx/conf.d/test1_backend.conf | cut -d: -f2)
              
              if [ "$CURRENT_PORT" = "${{ env.PORT_A }}" ]; then
                NEW_PORT="${{ env.PORT_B }}"
                NEW_PROCESS="${{ env.PROCESS_NAME }}-b"
                OLD_PROCESS="${{ env.PROCESS_NAME }}-a"
              else
                NEW_PORT="${{ env.PORT_A }}"
                NEW_PROCESS="${{ env.PROCESS_NAME }}-a"
                OLD_PROCESS="${{ env.PROCESS_NAME }}-b"
              fi
              echo "🔄 Port switch: $CURRENT_PORT → $NEW_PORT"
            fi
            
            # Add environment variables
            echo "PORT=$NEW_PORT" >> .env
            echo "NODE_ENV=production" >> .env
            echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> .env
            
            # Create optimized PM2 config
            cat > ecosystem.config.cjs << EOF
          module.exports = {
            apps: [{
              name: '$NEW_PROCESS',
              script: './node_modules/.bin/next',
              args: 'start',
              cwd: '$NEW_DEPLOYMENT_PATH',
              instances: 1,
              env: {
                NODE_ENV: 'production',
                PORT: '$NEW_PORT',
                NEXT_TELEMETRY_DISABLED: '1'
              },
              max_memory_restart: '512M',
              min_uptime: '5s',
              max_restarts: 3,
              autorestart: true,
              watch: false,
              kill_timeout: 5000,
              wait_ready: true,
              listen_timeout: 8000,
              error_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-error.log',
              out_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-out.log',
              time: true
            }]
          };
          EOF
            
            # Start new process
            echo "🚀 Starting $NEW_PROCESS on port $NEW_PORT..."
            pm2 start ecosystem.config.cjs
            
            # Fast health check with shorter intervals
            echo "⏳ Health check starting..."
            for i in {1..20}; do
              if curl -f -s --max-time 2 "http://localhost:$NEW_PORT/api/health" >/dev/null 2>&1; then
                echo "✅ Health check passed (${i}s)"
                break
              fi
              [ $i -eq 20 ] && { echo "❌ Health check timeout"; pm2 delete $NEW_PROCESS; exit 1; }
              sleep 1
            done
            
            # Update or create Nginx config
            echo "🔄 Updating Nginx..."
            sudo tee "/etc/nginx/conf.d/test1_backend.conf" > /dev/null << EOF
          upstream test1_backend {
              server 127.0.0.1:$NEW_PORT;
          }
          EOF
            
            # Test and reload Nginx
            if sudo nginx -t; then
              sudo nginx -s reload
              sleep 1
              
              # Health check endpoint - handle both first deployment and updates
              if [ "$FIRST_DEPLOYMENT" = true ]; then
                # For first deployment, check if service is accessible
                HEALTH_URL="https://${{ env.DOMAIN }}/api/health"
                echo "🔍 First deployment health check: $HEALTH_URL"
                
                for i in {1..10}; do
                  if curl -f -s --max-time 3 "$HEALTH_URL" >/dev/null 2>&1; then
                    echo "✅ First deployment successful!"
                    break
                  fi
                  [ $i -eq 10 ] && echo "⚠️ External health check failed, but deployment completed"
                  sleep 1
                done
              else
                # For updates, ensure external access works
                if curl -f -s --max-time 3 "https://${{ env.DOMAIN }}/api/health" >/dev/null 2>&1; then
                  echo "✅ Update successful!"
                  
                  # Stop old process
                  if [ -n "$OLD_PROCESS" ] && pm2 describe $OLD_PROCESS >/dev/null 2>&1; then
                    echo "🛑 Stopping old process: $OLD_PROCESS"
                    pm2 delete $OLD_PROCESS
                  fi
                else
                  echo "❌ External health check failed, rolling back..."
                  
                  # Rollback
                  if [ -n "$CURRENT_PORT" ]; then
                    sudo tee "/etc/nginx/conf.d/test1_backend.conf" > /dev/null << EOF
          upstream test1_backend {
              server 127.0.0.1:$CURRENT_PORT;
          }
          EOF
                    sudo nginx -s reload
                  fi
                  pm2 delete $NEW_PROCESS
                  exit 1
                fi
              fi
              
              # Update symlinks
              [ -L "$CURRENT_PATH" ] && rm "$CURRENT_PATH"
              ln -sfn "$NEW_DEPLOYMENT_PATH" "$CURRENT_PATH"
              
              # Update staging
              rm -rf "$STAGING_PATH"/* 2>/dev/null || true
              cp -r "$NEW_DEPLOYMENT_PATH"/* "$STAGING_PATH/"
              
              # Save PM2 and cleanup
              pm2 save
              cd "$DEPLOY_PATH/deployments" && ls -t | tail -n +4 | xargs -r rm -rf
              
              echo "🎉 Deployment completed in record time!"
              
            else
              echo "❌ Nginx config failed"
              pm2 delete $NEW_PROCESS
              exit 1
            fi
          DEPLOY_SCRIPT

      - name: 🔍 Quick Verify
        run: |
          ssh deploy << 'VERIFY_SCRIPT'
            echo "📊 PM2 Status:"
            pm2 status | grep "${{ env.PROCESS_NAME }}"
            
            echo "🌐 Health Check:"
            curl -s "https://${{ env.DOMAIN }}/api/health" || echo "Health endpoint not responding"
            
            echo "🔧 Active Port:"
            grep "127.0.0.1:" /etc/nginx/conf.d/test1_backend.conf
          VERIFY_SCRIPT

      - name: 🧹 Cleanup
        if: always()
        run: rm -f ~/.ssh/deploy_key deployment.tar.gz

  notify:
    needs: [build, deploy]
    runs-on: self-hosted
    if: always()
    steps:
      - name: 📢 Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "🎉 Ultra-fast deployment completed!"
            echo "⚡ Cache hit: ${{ needs.build.outputs.cache-hit }}"
            echo "🌍 Environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}"
          else
            echo "❌ Deployment failed!"
          fi