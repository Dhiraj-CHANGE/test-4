name: ‚ö° Test1 API Zero Downtime Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18'

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
    steps:
      - name: üìã Checkout
        uses: actions/checkout@v4

      - name: üìä Generate Metadata
        id: meta
        run: |
          DEPLOYMENT_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "üÜî Deployment ID: $DEPLOYMENT_ID"

      - name: ‚ö° Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üîß Install Dependencies
        run: npm ci --prefer-offline --no-audit

      - name: üèóÔ∏è Build Application
        run: |
          # Create any missing directories/files that might be needed
          mkdir -p styles public
          touch styles/globals.css
          
          # Build the application
          npm run build
          echo "‚úÖ Build completed"

      - name: üì¶ Create Deployment Package
        run: |
          tar -czf deployment.tar.gz .next node_modules public styles pages app package.json next.config.* 2>/dev/null || tar -czf deployment.tar.gz .next node_modules public styles package.json
          echo "üì¶ Package created: $(du -sh deployment.tar.gz | cut -f1)"

      - name: üöÄ Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ steps.meta.outputs.deployment-id }}
          path: deployment.tar.gz
          retention-days: 1

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: üì• Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-${{ needs.build.outputs.deployment-id }}
          path: .

      - name: ‚öôÔ∏è Setup Environment
        run: |
          BRANCH=${GITHUB_REF##*/}
          if [ "$BRANCH" = "main" ]; then
            echo "DEPLOY_PATH=${{ secrets.PROD_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.PROD_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.PROD_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.PROD_SSH_PORT }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.PROD_PROCESS_NAME}}" >> $GITHUB_ENV
          else
            echo "DEPLOY_PATH=${{ secrets.DEV_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.DEV_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.DEV_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.DEV_SSH_PORT }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.DEV_PROCESS_NAME}}" >> $GITHUB_ENV
          fi
          echo "DEPLOYMENT_ID=${{ needs.build.outputs.deployment-id }}" >> $GITHUB_ENV

      - name: üîê Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo '${{ secrets.PROD_SSH_PRIVATE_KEY }}' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          cat > ~/.ssh/config << EOF
          Host deploy
            HostName $SERVER
            User $USER
            Port $PORT_SSH
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF

      - name: üöÄ Deploy Application
        run: |
          ssh deploy "mkdir -p ${{ env.DEPLOY_PATH }}/staging"
          scp deployment.tar.gz deploy:${{ env.DEPLOY_PATH }}/staging/
          echo '${{ secrets.PROD_ENV_SECRET }}' | ssh deploy "cat > ${{ env.DEPLOY_PATH }}/staging/.env"
          
          ssh deploy << 'DEPLOY_SCRIPT'
            set -e
            
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            STAGING_PATH="$DEPLOY_PATH/staging"
            
            cd "$STAGING_PATH"
            
            # Extract deployment
            tar -xzf deployment.tar.gz
            rm deployment.tar.gz
            
            # Get current port
            CURRENT_PORT=$(grep -o "127.0.0.1:[0-9]*" /etc/nginx/conf.d/test1_backend.conf 2>/dev/null | cut -d: -f2 || echo "5005")
            
            # Switch port
            if [ "$CURRENT_PORT" = "5005" ]; then
              NEW_PORT="5006"
              NEW_PROCESS="${{ env.PROCESS_NAME }}-b"
              OLD_PROCESS="${{ env.PROCESS_NAME }}-a"
            else
              NEW_PORT="5005"
              NEW_PROCESS="${{ env.PROCESS_NAME }}-a"
              OLD_PROCESS="${{ env.PROCESS_NAME }}-b"
            fi
            
            echo "üîÑ Switching from port $CURRENT_PORT to $NEW_PORT"
            
            # Create missing files automatically (Vercel-style)
            mkdir -p styles public .next/server/pages
            touch styles/globals.css
            echo "<!DOCTYPE html><html><head><title>App</title></head><body><div id=\"__next\"></div></body></html>" > .next/server/pages/index.html 2>/dev/null || true
            
            # Add environment variables
            echo "PORT=$NEW_PORT" >> .env
            echo "NODE_ENV=production" >> .env
            
            # Create PM2 config
            cat > ecosystem.config.cjs << EOF
          module.exports = {
            apps: [{
              name: '$NEW_PROCESS',
              script: 'node_modules/.bin/next',
              args: 'start',
              cwd: '$STAGING_PATH',
              env: {
                NODE_ENV: 'production',
                PORT: '$NEW_PORT'
              },
              instances: 1,
              max_memory_restart: '512M',
              error_file: '$DEPLOY_PATH/logs/$NEW_PROCESS.log',
              out_file: '$DEPLOY_PATH/logs/$NEW_PROCESS.log',
              log_file: '$DEPLOY_PATH/logs/$NEW_PROCESS.log'
            }]
          };
          EOF
            
            # Start new process
            mkdir -p "$DEPLOY_PATH/logs"
            pm2 start ecosystem.config.cjs
            
            # Health check
            echo "‚è≥ Waiting for application to start..."
            sleep 10
            
            for i in {1..30}; do
              if curl -f -s "http://localhost:$NEW_PORT/api/health" >/dev/null 2>&1; then
                echo "‚úÖ Health check passed"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "‚ùå Health check failed"
                pm2 delete $NEW_PROCESS 2>/dev/null || true
                exit 1
              fi
              sleep 2
            done
            
            # Update Nginx
            sudo tee "/etc/nginx/conf.d/test1_backend.conf" > /dev/null << EOF
          upstream test1_backend {
              server 127.0.0.1:$NEW_PORT;
          }
          EOF
            
            sudo nginx -t && sudo nginx -s reload
            
            # Verify external access
            sleep 3
            if curl -f -s "https://test1.api.change-networks.com/api/health" >/dev/null 2>&1; then
              echo "‚úÖ External health check passed"
              
              # Stop old process
              pm2 delete $OLD_PROCESS 2>/dev/null || true
              
              # Move to current
              rm -rf "$DEPLOY_PATH/backup" 2>/dev/null || true
              mv "$DEPLOY_PATH/current" "$DEPLOY_PATH/backup" 2>/dev/null || true
              mv "$STAGING_PATH" "$DEPLOY_PATH/current"
              mkdir -p "$STAGING_PATH"
              
              pm2 save
              echo "üéâ Deployment successful!"
            else
              echo "‚ùå External health check failed, rolling back"
              sudo tee "/etc/nginx/conf.d/test1_backend.conf" > /dev/null << EOF
          upstream test1_backend {
              server 127.0.0.1:$CURRENT_PORT;
          }
          EOF
              sudo nginx -s reload
              pm2 delete $NEW_PROCESS 2>/dev/null || true
              exit 1
            fi
          DEPLOY_SCRIPT

      - name: üîç Verify Deployment
        run: |
          ssh deploy << 'VERIFY_SCRIPT'
            echo "üìä PM2 Status:"
            pm2 status
            echo ""
            echo "üåê Health Check:"
            curl -s https://test1.api.change-networks.com/api/health || echo "Health check endpoint not available"
            echo ""
            echo "üîß Nginx Config:"
            cat /etc/nginx/conf.d/test1_backend.conf
          VERIFY_SCRIPT

      - name: üßπ Cleanup
        if: always()
        run: rm -f ~/.ssh/deploy_key deployment.tar.gz

  notify:
    needs: [build, deploy]
    runs-on: self-hosted
    if: always()
    steps:
      - name: üì¢ Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "üéâ Deployment successful!"
            echo "üîó https://test1.api.change-networks.com"
          else
            echo "‚ùå Deployment failed!"
          fi