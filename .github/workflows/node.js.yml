name: Deploy Next.js App

on:
  push:
    branches:
      - main
      - dev

env:
  NODE_VERSION: '18'
  ARTIFACT_RETENTION_DAYS: 3

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.deployment-id.outputs.id }}
    steps:
      - name: âœ… Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ”§ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ“‹ Generate Deployment ID
        id: deployment-id
        run: echo "id=$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT

      - name: âš™ï¸ Install Dependencies
        run: |
          npm ci --prefer-offline --no-audit
          echo "âœ… Dependencies installed successfully"

      - name: ğŸ—ï¸ Build Application
        run: |
          npm run build
          echo "âœ… Application built successfully"

      - name: ğŸ“¦ Prepare Production Files
        run: |
          set -e
          
          # Create output directory
          mkdir -p output
          
          # Copy built application
          cp -r .next output/
          
          # Copy public directory if it exists
          if [ -d "public" ]; then
            cp -r public output/
            echo "âœ… Public directory copied"
          else
            echo "â„¹ï¸ No public directory found"
          fi
          
          # Copy package files
          cp package.json package-lock.json output/
          
          # Create optimized package.json for production
          node -e "
            const pkg = require('./package.json');
            const prodPkg = {
              name: pkg.name,
              version: pkg.version,
              private: pkg.private,
              scripts: {
                start: 'next start'
              },
              dependencies: pkg.dependencies
            };
            require('fs').writeFileSync('output/package.json', JSON.stringify(prodPkg, null, 2));
            console.log('âœ… Production package.json created');
          "
          
          # Install production dependencies
          cd output
          npm ci --production --prefer-offline --no-audit
          cd ..
          
          # Create deployment info
          cat > output/deployment-info.json << EOF
          {
            "deploymentId": "${{ steps.deployment-id.outputs.id }}",
            "branch": "${GITHUB_REF##*/}",
            "commit": "${GITHUB_SHA}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "nodeVersion": "${{ env.NODE_VERSION }}"
          }
          EOF
          
          echo "âœ… Production files prepared successfully"

      - name: ğŸ“¤ Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: next-build-${{ steps.deployment-id.outputs.id }}
          path: output
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}
          compression-level: 9

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: ğŸ“¥ Download Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: next-build-${{ needs.build.outputs.deployment-id }}
          path: build

      - name: âš™ï¸ Configure Deployment Environment
        id: config
        run: |
          set -e
          
          BRANCH=${GITHUB_REF##*/}
          DEPLOYMENT_ID="${{ needs.build.outputs.deployment-id }}"
          
          # Create secure temporary directory
          TEMP_DIR=$(mktemp -d)
          echo "TEMP_DIR=$TEMP_DIR" >> $GITHUB_ENV
          
          if [ "$BRANCH" = "main" ]; then
            echo "ğŸš€ Configuring PRODUCTION deployment"
            echo "DEPLOY_DIR=/var/www/testing/_work/test-4" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.PROD_SERVER_HOST }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.PROD_PROCESS_NAME }}" >> $GITHUB_ENV
            echo "REMOTE_USER=${{ secrets.PROD_SERVER_USER }}" >> $GITHUB_ENV
            echo "SSH_PORT=${{ secrets.PROD_SSH_PORT }}" >> $GITHUB_ENV
            echo "PORT=5005" >> $GITHUB_ENV
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
            
            # Setup SSH key
            echo "${{ secrets.PROD_SSH_PRIVATE_KEY }}" > "$TEMP_DIR/ssh_key"
            echo "${{ secrets.PROD_ENV_SECRET }}" > "$TEMP_DIR/.env.production"
            
          elif [ "$BRANCH" = "dev" ]; then
            echo "ğŸ§ª Configuring DEVELOPMENT deployment"
            echo "DEPLOY_DIR=/var/www/testing/_work/test-4-dev" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.DEV_SERVER_HOST }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.DEV_PROCESS_NAME }}" >> $GITHUB_ENV
            echo "REMOTE_USER=${{ secrets.DEV_SERVER_USER }}" >> $GITHUB_ENV
            echo "SSH_PORT=${{ secrets.DEV_SSH_PORT }}" >> $GITHUB_ENV
            echo "PORT=5001" >> $GITHUB_ENV
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
            
            # Setup SSH key
            echo "${{ secrets.DEV_SSH_PRIVATE_KEY }}" > "$TEMP_DIR/ssh_key"
            echo "${{ secrets.DEV_ENV_SECRET }}" > "$TEMP_DIR/.env.production"
            
          else
            echo "âŒ Unsupported branch: $BRANCH"
            exit 1
          fi
          
          # Set secure permissions
          chmod 600 "$TEMP_DIR/ssh_key" "$TEMP_DIR/.env.production"
          
          echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> $GITHUB_ENV
          echo "âœ… Environment configured for $ENVIRONMENT"

      - name: ğŸ” Setup SSH Configuration
        run: |
          set -e
          
          # Create SSH config
          cat > "$TEMP_DIR/ssh_config" << EOF
          Host deploy-server
            HostName $SERVER
            User $REMOTE_USER
            Port $SSH_PORT
            IdentityFile $TEMP_DIR/ssh_key
            IdentitiesOnly yes
            StrictHostKeyChecking no
            ServerAliveInterval 30
            ServerAliveCountMax 3
            ConnectTimeout 10
            BatchMode yes
          EOF
          
          chmod 600 "$TEMP_DIR/ssh_config"
          echo "âœ… SSH configuration created"

      - name: ğŸ“¦ Create Deployment Package
        run: |
          set -e
          
          # Copy environment file to build
          cp "$TEMP_DIR/.env.production" build/
          
          # Create deployment package
          cd build
          tar -czf "$TEMP_DIR/deployment.tar.gz" .
          cd ..
          
          # Verify package
          if [ ! -f "$TEMP_DIR/deployment.tar.gz" ]; then
            echo "âŒ Failed to create deployment package"
            exit 1
          fi
          
          PACKAGE_SIZE=$(du -h "$TEMP_DIR/deployment.tar.gz" | cut -f1)
          echo "âœ… Deployment package created (Size: $PACKAGE_SIZE)"

      - name: ğŸš€ Deploy with Zero Downtime
        run: |
          set -e
          
          SSH_CMD="ssh -F $TEMP_DIR/ssh_config deploy-server"
          SCP_CMD="scp -F $TEMP_DIR/ssh_config"
          
          echo "ğŸ” Testing server connection..."
          if ! $SSH_CMD "echo 'Connection successful'"; then
            echo "âŒ Failed to connect to server"
            exit 1
          fi
          
          echo "ğŸ“ Creating release directory..."
          $SSH_CMD "mkdir -p $DEPLOY_DIR/releases/$DEPLOYMENT_ID"
          
          echo "ğŸ“¤ Uploading deployment package..."
          $SCP_CMD "$TEMP_DIR/deployment.tar.gz" deploy-server:$DEPLOY_DIR/releases/$DEPLOYMENT_ID/
          
          echo "ğŸ”§ Deploying application..."
          $SSH_CMD << EOF
            set -e
            cd $DEPLOY_DIR/releases/$DEPLOYMENT_ID
            
            # Extract deployment package
            echo "ğŸ“¦ Extracting files..."
            tar -xzf deployment.tar.gz
            rm deployment.tar.gz
            
            # Create PM2 ecosystem file
            echo "âš™ï¸ Creating PM2 configuration..."
            cat > ecosystem.config.js << EOL
          module.exports = {
            apps: [{
              name: '$PROCESS_NAME',
              script: './node_modules/.bin/next',
              args: 'start',
              cwd: '$DEPLOY_DIR/current',
              env: {
                NODE_ENV: 'production',
                PORT: '$PORT'
              },
              instances: 1,
              exec_mode: 'cluster',
              max_memory_restart: '1G',
              min_uptime: '10s',
              max_restarts: 5,
              error_file: '$DEPLOY_DIR/logs/\$PROCESS_NAME-error.log',
              out_file: '$DEPLOY_DIR/logs/\$PROCESS_NAME-out.log',
              log_file: '$DEPLOY_DIR/logs/\$PROCESS_NAME.log',
              time: true,
              autorestart: true,
              watch: false,
              ignore_watch: ['node_modules', 'logs'],
              env_production: {
                NODE_ENV: 'production',
                PORT: '$PORT'
              }
            }]
          };
          EOL
            
            # Create necessary directories
            mkdir -p $DEPLOY_DIR/logs
            
            # Health check function
            health_check() {
              local max_attempts=30
              local attempt=1
              
              while [ \$attempt -le \$max_attempts ]; do
                if curl -f -s http://localhost:$PORT/api/health > /dev/null 2>&1 || curl -f -s http://localhost:$PORT > /dev/null 2>&1; then
                  echo "âœ… Health check passed (attempt \$attempt)"
                  return 0
                fi
                echo "â³ Health check attempt \$attempt/\$max_attempts failed, retrying..."
                sleep 2
                attempt=\$((attempt + 1))
              done
              
              echo "âŒ Health check failed after \$max_attempts attempts"
              return 1
            }
            
            # Backup current symlink if it exists
            if [ -L "$DEPLOY_DIR/current" ]; then
              BACKUP_RELEASE=\$(readlink $DEPLOY_DIR/current)
              echo "ğŸ’¾ Backup release: \$BACKUP_RELEASE"
            fi
            
            # Update symlink atomically
            echo "ğŸ”„ Switching to new release..."
            ln -snf $DEPLOY_DIR/releases/$DEPLOYMENT_ID $DEPLOY_DIR/current
            
            # Deploy with PM2
            if pm2 describe $PROCESS_NAME > /dev/null 2>&1; then
              echo "ğŸ”„ Reloading existing PM2 process..."
              pm2 reload ecosystem.config.js --env production
            else
              echo "ğŸš€ Starting new PM2 process..."
              pm2 start ecosystem.config.js --env production
            fi
            
            # Wait for application to start
            sleep 5
            
            # Perform health check
            if health_check; then
              echo "âœ… Deployment successful!"
              pm2 save
              
              # Clean up old releases (keep last 5)
              echo "ğŸ§¹ Cleaning up old releases..."
              cd $DEPLOY_DIR/releases
              ls -t | tail -n +6 | xargs -r rm -rf
              echo "âœ… Cleanup completed"
              
            else
              echo "âŒ Health check failed, rolling back..."
              if [ -n "\$BACKUP_RELEASE" ] && [ -d "\$BACKUP_RELEASE" ]; then
                ln -snf \$BACKUP_RELEASE $DEPLOY_DIR/current
                pm2 reload ecosystem.config.js --env production
                echo "ğŸ”„ Rollback completed"
              fi
              exit 1
            fi
          EOF
          
          echo "ğŸ‰ Deployment completed successfully!"

      - name: ğŸ“Š Post-Deployment Verification
        run: |
          set -e
          
          SSH_CMD="ssh -F $TEMP_DIR/ssh_config deploy-server"
          
          echo "ğŸ” Verifying deployment..."
          
          # Check PM2 status
          $SSH_CMD "pm2 status $PROCESS_NAME"
          
          # Check if application is responding
          if $SSH_CMD "curl -f -s http://localhost:$PORT > /dev/null"; then
            echo "âœ… Application is responding correctly"
          else
            echo "âš ï¸ Application health check warning"
          fi
          
          # Display deployment info
          $SSH_CMD "cat $DEPLOY_DIR/current/deployment-info.json" || echo "â„¹ï¸ Deployment info not available"

      - name: ğŸ§¹ Cleanup
        if: always()
        run: |
          if [ -n "$TEMP_DIR" ] && [ -d "$TEMP_DIR" ]; then
            rm -rf "$TEMP_DIR"
            echo "âœ… Temporary files cleaned up"
          fi

      - name: ğŸ“¢ Deployment Notification
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "ğŸ‰ Deployment to $ENVIRONMENT completed successfully!"
            echo "ğŸ“‹ Deployment ID: $DEPLOYMENT_ID"
            echo "ğŸŒ Environment: $ENVIRONMENT"
            echo "ğŸ”— Server: $SERVER:$PORT"
          else
            echo "âŒ Deployment to $ENVIRONMENT failed!"
            echo "ğŸ“‹ Deployment ID: $DEPLOYMENT_ID"
          fi