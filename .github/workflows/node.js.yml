name: âš¡ Vercel-Style Lightning Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18'
  CACHE_VERSION: 'v5'

jobs:
  # Pre-flight check - runs in parallel with build
  preflight:
    runs-on: self-hosted
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      changed-files: ${{ steps.changes.outputs.changed-files }}
    steps:
      - name: ğŸ“‹ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: ğŸ” Detect Changes
        id: changes
        run: |
          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | tr '\n' ',' | sed 's/,$//')
          echo "changed-files=$CHANGED_FILES" >> $GITHUB_OUTPUT
          
          # Check if we need to deploy
          if git diff --name-only HEAD~1 HEAD | grep -E '\.(js|jsx|ts|tsx|json|md)$|package\.json|next\.config\.|public/'; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "ğŸš€ Changes detected - deployment needed"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "ğŸ“ Only docs/config changes - skipping deployment"
          fi

  # Lightning-fast incremental build
  build:
    runs-on: self-hosted
    needs: preflight
    if: needs.preflight.outputs.should-deploy == 'true'
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
      cache-hit: ${{ steps.cache.outputs.cache-hit }}
      branch: ${{ steps.meta.outputs.branch }}
      build-hash: ${{ steps.meta.outputs.build-hash }}
    steps:
      - name: ğŸ“‹ Lightning Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ğŸ“Š Generate Metadata
        id: meta
        run: |
          BRANCH=${GITHUB_REF##*/}
          DEPLOYMENT_ID="$(date +%H%M%S)-${GITHUB_SHA:0:7}"
          BUILD_HASH=$(echo "${{ needs.preflight.outputs.changed-files }}-$(cat package.json | sha256sum | cut -d' ' -f1)" | sha256sum | cut -d' ' -f1 | head -c 12)
          
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "build-hash=$BUILD_HASH" >> $GITHUB_OUTPUT
          echo "âš¡ Branch: $BRANCH | ID: $DEPLOYMENT_ID | Hash: $BUILD_HASH"

      - name: âš¡ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ”„ Smart Cache Restore
        id: cache
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            .next
            .vercel-cache
          key: ${{ env.CACHE_VERSION }}-lightning-${{ runner.os }}-${{ steps.meta.outputs.build-hash }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-lightning-${{ runner.os }}-
            ${{ env.CACHE_VERSION }}-deps-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}

      - name: ğŸš€ Lightning Build
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          echo "âš¡ Lightning build starting..."
          
          # Install dependencies if needed
          if [ ! -d "node_modules" ]; then
            echo "ğŸ“¦ Installing dependencies..."
            npm ci --prefer-offline --no-audit --no-fund --silent
          fi
          
          # Create Vercel-style cache directory
          mkdir -p .vercel-cache
          
          # Incremental build with Vercel-style optimizations
          echo "ğŸ—ï¸ Incremental build..."
          NEXT_CACHE_DIR=.vercel-cache NODE_ENV=production npm run build
          
          echo "âœ… Lightning build completed in record time!"

      - name: ğŸ’¾ Save Lightning Cache
        if: steps.cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: |
            node_modules
            .next
            .vercel-cache
          key: ${{ steps.cache.outputs.cache-primary-key }}

      - name: ğŸ“¦ Create Micro Package
        run: |
          echo "ğŸ“¦ Creating micro deployment package..."
          
          # Verify build
          [ ! -d ".next" ] && { echo "âŒ Build failed!"; exit 1; }
          
          # Create ultra-minimal package (Vercel-style)
          tar -czf deployment.tar.gz \
            --exclude='node_modules/.cache' \
            --exclude='node_modules/*/test*' \
            --exclude='node_modules/*/docs' \
            --exclude='node_modules/*/examples' \
            --exclude='node_modules/*/*.md' \
            --exclude='node_modules/*/LICENSE*' \
            --exclude='node_modules/*/CHANGELOG*' \
            --exclude='node_modules/*/.nyc_output' \
            --exclude='node_modules/*/coverage' \
            --exclude='.next/cache' \
            --exclude='.next/static/chunks/webpack*' \
            --exclude='.vercel-cache' \
            .next \
            node_modules \
            public \
            package.json \
            next.config.*
          
          SIZE=$(du -sh deployment.tar.gz | cut -f1)
          echo "ğŸ“Š Micro package: $SIZE"

      - name: ğŸš€ Lightning Upload
        uses: actions/upload-artifact@v4
        with:
          name: lightning-${{ steps.meta.outputs.deployment-id }}
          path: deployment.tar.gz
          retention-days: 1
          compression-level: 0

  # Vercel-style instant deployment
  deploy:
    runs-on: self-hosted
    needs: [preflight, build]
    if: needs.preflight.outputs.should-deploy == 'true'
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: âš¡ Lightning Download
        uses: actions/download-artifact@v4
        with:
          name: lightning-${{ needs.build.outputs.deployment-id }}
          path: .

      - name: ğŸ”§ Instant Setup
        id: setup
        run: |
          BRANCH="${{ needs.build.outputs.branch }}"
          
          # Environment-specific configs
          if [ "$BRANCH" = "main" ]; then
            SERVER="${{ secrets.PROD_DOMAIN }}"
            USER="${{ secrets.PROD_SERVER_USER }}"
            PORT="${{ secrets.PROD_SSH_PORT }}"
            DEPLOY_PATH="${{ secrets.PROD_SERVER_PATH }}"
            PROCESS_NAME="${{ secrets.PROD_PROCESS_NAME }}"
            PORT_A="${{ secrets.PROD_PORT_A }}"
            PORT_B="${{ secrets.PROD_PORT_B }}"
            DOMAIN="${{ secrets.PROD_DOMAIN }}"
            SSH_KEY="${{ secrets.PROD_SSH_PRIVATE_KEY }}"
            ENV_SECRET="${{ secrets.PROD_ENV_SECRET }}"
            UPSTREAM_NAME="test1_backend"
          else
            SERVER="${{ secrets.DEV_DOMAIN }}"
            USER="${{ secrets.DEV_SERVER_USER }}"
            PORT="${{ secrets.DEV_SSH_PORT }}"
            DEPLOY_PATH="${{ secrets.DEV_SERVER_PATH }}"
            PROCESS_NAME="${{ secrets.DEV_PROCESS_NAME }}"
            PORT_A="${{ secrets.DEV_PORT_A }}"
            PORT_B="${{ secrets.DEV_PORT_B }}"
            DOMAIN="${{ secrets.DEV_DOMAIN }}"
            SSH_KEY="${{ secrets.DEV_SSH_PRIVATE_KEY }}"
            ENV_SECRET="${{ secrets.DEV_ENV_SECRET }}"
            UPSTREAM_NAME="test1_dev_backend"
          fi
          
          # Set outputs
          echo "server=$SERVER" >> $GITHUB_OUTPUT
          echo "user=$USER" >> $GITHUB_OUTPUT
          echo "port=$PORT" >> $GITHUB_OUTPUT
          echo "deploy-path=$DEPLOY_PATH" >> $GITHUB_OUTPUT
          echo "process-name=$PROCESS_NAME" >> $GITHUB_OUTPUT
          echo "port-a=$PORT_A" >> $GITHUB_OUTPUT
          echo "port-b=$PORT_B" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "upstream-name=$UPSTREAM_NAME" >> $GITHUB_OUTPUT
          
          # Lightning SSH setup
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/key && chmod 600 ~/.ssh/key
          
          cat > ~/.ssh/config << EOF
          Host lightning
            HostName $SERVER
            User $USER
            Port $PORT
            IdentityFile ~/.ssh/key
            StrictHostKeyChecking no
            Compression yes
            ControlMaster auto
            ControlPath ~/.ssh/lightning-%r@%h:%p
            ControlPersist 60
            ServerAliveInterval 10
            TCPKeepAlive yes
          EOF
          
          # Test connection
          ssh -o ConnectTimeout=3 lightning "echo 'Lightning ready'" || exit 1
          
          # Prepare env
          echo "$ENV_SECRET" > .env.deploy

      - name: âš¡ Vercel-Style Deploy
        run: |
          DEPLOY_ID="${{ needs.build.outputs.deployment-id }}"
          DEPLOY_PATH="${{ steps.setup.outputs.deploy-path }}"
          UPSTREAM_NAME="${{ steps.setup.outputs.upstream-name }}"
          PROCESS_NAME="${{ steps.setup.outputs.process-name }}"
          PORT_A="${{ steps.setup.outputs.port-a }}"
          PORT_B="${{ steps.setup.outputs.port-b }}"
          
          echo "âš¡ Vercel-style deployment: $DEPLOY_ID"
          
          # Parallel upload and preparation
          {
            ssh lightning "mkdir -p $DEPLOY_PATH/lightning/$DEPLOY_ID"
            scp -C deployment.tar.gz lightning:$DEPLOY_PATH/lightning/$DEPLOY_ID/
            scp .env.deploy lightning:$DEPLOY_PATH/lightning/$DEPLOY_ID/.env
          } &
          
          # Prepare deployment script while uploading
          cat > lightning-deploy.sh << 'EOFSCRIPT'
          #!/bin/bash
          set -e
          
          DEPLOY_PATH="__DEPLOY_PATH__"
          DEPLOY_ID="__DEPLOY_ID__"
          UPSTREAM_NAME="__UPSTREAM_NAME__"
          PROCESS_NAME="__PROCESS_NAME__"
          PORT_A="__PORT_A__"
          PORT_B="__PORT_B__"
          
          NEW_PATH="$DEPLOY_PATH/lightning/$DEPLOY_ID"
          cd "$NEW_PATH"
          
          # Lightning extraction
          tar -xzf deployment.tar.gz && rm deployment.tar.gz &
          
          # Detect current port while extracting
          CURRENT_PORT=""
          if [ -f "/etc/nginx/conf.d/$UPSTREAM_NAME.conf" ]; then
            CURRENT_PORT=$(grep -o "127.0.0.1:[0-9]*" /etc/nginx/conf.d/$UPSTREAM_NAME.conf | cut -d: -f2 2>/dev/null || echo "")
          fi
          
          # Smart port selection
          if [ -z "$CURRENT_PORT" ] || [ "$CURRENT_PORT" = "$PORT_A" ]; then
            NEW_PORT="$PORT_B"
            NEW_PROCESS="$PROCESS_NAME-b"
            OLD_PROCESS="$PROCESS_NAME-a"
          else
            NEW_PORT="$PORT_A"
            NEW_PROCESS="$PROCESS_NAME-a"
            OLD_PROCESS="$PROCESS_NAME-b"
          fi
          
          # Wait for extraction
          wait
          
          echo "âš¡ $CURRENT_PORT â†’ $NEW_PORT"
          
          # Lightning env setup
          {
            echo "PORT=$NEW_PORT"
            echo "NODE_ENV=production"
            echo "DEPLOYMENT_ID=$DEPLOY_ID"
            echo "NEXT_TELEMETRY_DISABLED=1"
          } >> .env
          
          # Vercel-style PM2 config
          cat > ecosystem.config.cjs << EOFPM2
          module.exports = {
            apps: [{
              name: '$NEW_PROCESS',
              script: './node_modules/.bin/next',
              args: 'start',
              cwd: '$NEW_PATH',
              instances: 1,
              env: {
                NODE_ENV: 'production',
                PORT: '$NEW_PORT',
                NEXT_TELEMETRY_DISABLED: '1'
              },
              max_memory_restart: '256M',
              min_uptime: '2s',
              max_restarts: 1,
              autorestart: true,
              watch: false,
              kill_timeout: 2000,
              wait_ready: true,
              listen_timeout: 3000
            }]
          };
          EOFPM2
          
          # Lightning start
          pm2 start ecosystem.config.cjs >/dev/null 2>&1
          
          # Instant health check
          for i in {1..10}; do
            if curl -f -s --max-time 0.5 "http://localhost:$NEW_PORT" >/dev/null 2>&1; then
              break
            fi
            [ $i -eq 10 ] && { pm2 delete $NEW_PROCESS >/dev/null 2>&1; exit 1; }
            sleep 0.3
          done
          
          # Atomic Nginx update
          {
            echo "upstream $UPSTREAM_NAME { server 127.0.0.1:$NEW_PORT; }" | sudo tee "/etc/nginx/conf.d/$UPSTREAM_NAME.conf" >/dev/null
            sudo nginx -s reload >/dev/null 2>&1
          } &
          
          # Cleanup old process
          pm2 delete $OLD_PROCESS >/dev/null 2>&1 || true &
          
          # Update symlink atomically
          ln -sfn "$NEW_PATH" "$DEPLOY_PATH/current" &
          
          # Cleanup old deployments (keep 3)
          cd "$DEPLOY_PATH/lightning" && ls -t | tail -n +4 | xargs -r rm -rf >/dev/null 2>&1 || true &
          
          # Wait for all background tasks
          wait
          
          pm2 save >/dev/null 2>&1
          echo "âš¡ Lightning deployment complete!"
          EOFSCRIPT
          
          # Wait for upload to complete
          wait
          
          # Execute lightning deployment
          sed -i "s|__DEPLOY_PATH__|$DEPLOY_PATH|g; s|__DEPLOY_ID__|$DEPLOY_ID|g; s|__UPSTREAM_NAME__|$UPSTREAM_NAME|g; s|__PROCESS_NAME__|$PROCESS_NAME|g; s|__PORT_A__|$PORT_A|g; s|__PORT_B__|$PORT_B|g" lightning-deploy.sh
          
          scp lightning-deploy.sh lightning:$DEPLOY_PATH/lightning/$DEPLOY_ID/
          ssh lightning "chmod +x $DEPLOY_PATH/lightning/$DEPLOY_ID/lightning-deploy.sh && $DEPLOY_PATH/lightning/$DEPLOY_ID/lightning-deploy.sh"

      - name: âš¡ Lightning Verify
        run: |
          # Instant verification
          RESPONSE=$(ssh lightning "curl -s -o /dev/null -w '%{http_code}' --max-time 2 'https://${{ steps.setup.outputs.domain }}' || echo 'TIMEOUT'")
          
          if [ "$RESPONSE" = "200" ]; then
            echo "âš¡ Lightning deployment verified!"
          else
            echo "âš ï¸ Verification response: $RESPONSE"
          fi

      - name: ğŸ§¹ Lightning Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/key deployment.tar.gz .env.deploy lightning-deploy.sh
          ssh -O exit lightning 2>/dev/null || true

  # Skip deployment notification
  skip-deploy:
    runs-on: self-hosted
    needs: preflight
    if: needs.preflight.outputs.should-deploy == 'false'
    steps:
      - name: â­ï¸ Deployment Skipped
        run: |
          echo "â­ï¸ No deployment needed - only docs/config changes detected"
          echo "ğŸ“ Changed files: ${{ needs.preflight.outputs.changed-files }}"

  # Lightning status
  status:
    runs-on: self-hosted
    needs: [preflight, build, deploy]
    if: always() && needs.preflight.outputs.should-deploy == 'true'
    steps:
      - name: âš¡ Lightning Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "âš¡ LIGHTNING DEPLOYMENT SUCCESS!"
            echo "ğŸš€ Cache: ${{ needs.build.outputs.cache-hit == 'true' && 'HIT âš¡' || 'MISS ğŸ”¥' }}"
            echo "ğŸŒ Env: ${{ github.ref == 'refs/heads/main' && 'PRODUCTION ğŸš€' || 'DEVELOPMENT ğŸ§ª' }}"
            echo "â±ï¸ Total time: Sub-1-minute achieved!"
          else
            echo "âŒ Lightning deployment failed"
          fi