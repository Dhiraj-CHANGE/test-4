# .github/workflows/deploy.yml
name: âš¡ Test1 API Zero Downtime Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18' # Ensure this matches your server's Node.js version if not managed by nvm/similar

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
      package-hash: ${{ steps.hash.outputs.package-hash }}
    steps:
      - name: ðŸ“‹ Checkout
        uses: actions/checkout@v4

      - name: ðŸ“Š Generate Metadata
        id: meta
        run: |
          DEPLOYMENT_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "ðŸ†” Deployment ID: $DEPLOYMENT_ID"

      - name: ðŸ“Š Generate Package Hash
        id: hash
        run: |
          # Use package-lock.json for more consistent caching
          PACKAGE_HASH=$(sha256sum package.json package-lock.json | sha256sum | cut -d ' ' -f 1)
          echo "package-hash=$PACKAGE_HASH" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Package Hash: $PACKAGE_HASH"

      - name: â™»ï¸ Cache Node Modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: âš¡ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ðŸ”§ Install Dependencies
        run: |
          # Check if node_modules exists and is not empty
          if [ ! -d "node_modules" ] || [ -z "$(ls -A node_modules)" ]; then
            echo "ðŸ“¦ Installing dependencies..."
            npm ci --prefer-offline --no-audit --progress=false
          else
            echo "ðŸ“¦ Using cached dependencies"
          fi

      - name: ðŸ—ï¸ Build Application
        run: |
          # Ensure next.config.js (or .ts/.mjs) is present before building if your project relies on it
          # This build step directly uses your repository's Next.js configuration.
          npm run build
          echo "âœ… Build completed"

      - name: ðŸ“¦ Create Deployment Package
        run: |
          # Package essential Next.js build artifacts
          # Add || true to next.config.js to prevent failure if it doesn't exist (e.g., using default Next.js behavior)
          tar -czf deployment.tar.gz .next public package.json package-lock.json next.config.js || true

          echo "ðŸ“¦ Package size: $(du -sh deployment.tar.gz | cut -f1)"

      - name: ðŸš€ Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ steps.meta.outputs.deployment-id }}
          path: deployment.tar.gz
          retention-days: 1

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: ðŸ“¥ Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-${{ needs.build.outputs.deployment-id }}
          path: .

      - name: âš™ï¸ Setup Environment Variables
        run: |
          BRANCH=${GITHUB_REF##*/} # Extract branch name from GITHUB_REF
          
          if [ "$BRANCH" = "main" ]; then
            echo "DEPLOY_PATH=${{ secrets.PROD_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.PROD_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.PROD_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.PROD_SSH_PORT }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.PROD_PROCESS_NAME}}" >> $GITHUB_ENV
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          else
            echo "DEPLOY_PATH=${{ secrets.DEV_SERVER_PATH }}" >> $GITHUB_ENV
            echo "SERVER=${{ secrets.DEV_SERVER_HOST }}" >> $GITHUB_ENV
            echo "USER=${{ secrets.DEV_SERVER_USER }}" >> $GITHUB_ENV
            echo "PORT_SSH=${{ secrets.DEV_SSH_PORT }}" >> $GITHUB_ENV
            echo "PROCESS_NAME=${{ secrets.DEV_PROCESS_NAME}}" >> $GITHUB_ENV
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
          fi
          
          echo "DEPLOYMENT_ID=${{ needs.build.outputs.deployment-id }}" >> $GITHUB_ENV
          echo "PACKAGE_HASH=${{ needs.build.outputs.package-hash }}" >> $GITHUB_ENV

      - name: ðŸ” Setup SSH
        run: |
          mkdir -p ~/.ssh
          # Use PROD_SSH_PRIVATE_KEY for both environments, assuming your self-hosted runner
          # uses a single key to connect to both dev and prod servers.
          # If distinct keys are needed, use conditional logic here.
          echo '${{ secrets.PROD_SSH_PRIVATE_KEY }}' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Configure SSH for the 'deploy' alias
          cat > ~/.ssh/config << EOF
          Host deploy
            HostName $SERVER
            User $USER
            Port $PORT_SSH
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            ServerAliveInterval 30
            ConnectTimeout 10
          EOF

      - name: ðŸš€ Zero-Downtime Deploy with Port Switching
        run: |
          # Create staging directory on server first
          ssh deploy "mkdir -p ${{ env.DEPLOY_PATH }}/staging"
          
          # Upload deployment package
          echo "ðŸ“¤ Uploading deployment package..."
          scp deployment.tar.gz deploy:${{ env.DEPLOY_PATH }}/staging/deployment.tar.gz
          
          # Copy environment variables (use the correct secret for the environment)
          if [ "${{ github.ref == 'refs/heads/main' }}" = "true" ]; then
            echo "${{ secrets.PROD_ENV_SECRET }}" | ssh deploy "cat > ${{ env.DEPLOY_PATH }}/staging/.env"
          else
            echo "${{ secrets.DEV_ENV_SECRET }}" | ssh deploy "cat > ${{ env.DEPLOY_PATH }}/staging/.env"
          fi
          
          # Execute zero-downtime deployment with port switching on the remote server
          ssh deploy << 'DEPLOY_SCRIPT'
            set -e # Exit immediately if a command exits with a non-zero status

            # Define paths based on GitHub Actions environment variables
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            STAGING_PATH="$DEPLOY_PATH/staging"
            CURRENT_PATH="$DEPLOY_PATH/current"
            BACKUP_PATH="$DEPLOY_PATH/backup"
            PROCESS_NAME="${{ env.PROCESS_NAME }}" # Base process name

            echo "ðŸ“ Entering staging directory: $STAGING_PATH"
            cd "$STAGING_PATH"
            
            # Extract new deployment package
            echo "ðŸ“¦ Extracting deployment package..."
            tar -xzf deployment.tar.gz
            rm deployment.tar.gz
            
            # Remove any potentially conflicting Next.js config files (e.g., if you switched from .ts to .js)
            rm -f next.config.ts next.config.mjs
            
            # Check current Nginx upstream port
            CURRENT_PORT=""
            if [ -f "/etc/nginx/conf.d/test1_backend.conf" ]; then
              CURRENT_PORT=$(grep -o "127.0.0.1:[0-9]*" /etc/nginx/conf.d/test1_backend.conf | cut -d: -f2)
            fi
            
            # If no current port found, default to 5005 (initial port for first deployment)
            if [ -z "$CURRENT_PORT" ]; then
              CURRENT_PORT="5005"
            fi
            
            # Determine new port (switch between 5005 and 5006 for blue/green deployment)
            if [ "$CURRENT_PORT" = "5005" ]; then
              NEW_PORT="5006"
              NEW_PROCESS="${PROCESS_NAME}-b"
              OLD_PROCESS="${PROCESS_NAME}-a"
            else
              NEW_PORT="5005"
              NEW_PROCESS="${PROCESS_NAME}-a"
              OLD_PROCESS="${PROCESS_NAME}-b"
            fi
            
            echo "ðŸ”„ Current port: $CURRENT_PORT, New port: $NEW_PORT"
            echo "ðŸ”„ New process name: $NEW_PROCESS, Old process name: $OLD_PROCESS"
            
            # Install production dependencies only
            # The .next build output already contains the necessary Next.js framework files.
            echo "ðŸ“¦ Installing production dependencies..."
            rm -rf node_modules # Remove existing node_modules to ensure a fresh install
            npm install --omit=dev --prefer-offline --no-audit --progress=false
            
            # Verify Next.js binary presence
            if [ ! -f "node_modules/.bin/next" ]; then
              echo "âŒ Next.js binary not found after installation in $STAGING_PATH/node_modules/.bin"
              exit 1
            fi
            
            echo "âœ… Dependencies installed and verified in staging"
            
            # Add explicit Next.js telemetry disable to the .env file
            echo "NEXT_TELEMETRY_DISABLED=1" >> .env
            
            # Ensure logs directory exists
            mkdir -p "$DEPLOY_PATH/logs"
            
            # Create PM2 ecosystem file for the NEW process in the STAGING directory
            cat > ecosystem.config.js << EOF
            module.exports = {
              apps: [{
                name: '$NEW_PROCESS',
                script: '$STAGING_PATH/node_modules/.bin/next', # Absolute path to next binary
                args: 'start',
                cwd: '$STAGING_PATH', # Current Working Directory for PM2 process
                instances: 1,
                exec_mode: 'cluster',
                env: {
                  NODE_ENV: 'production',
                  PORT: '$NEW_PORT',
                  PWD: '$STAGING_PATH', # PWD environment variable
                  NEXT_TELEMETRY_DISABLED: '1'
                },
                max_memory_restart: '512M',
                min_uptime: '10s',
                max_restarts: 3,
                autorestart: true,
                watch: false,
                kill_timeout: 8000,
                wait_ready: true,
                listen_timeout: 15000,
                error_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-error.log',
                out_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-out.log',
                log_file: '$DEPLOY_PATH/logs/$NEW_PROCESS.log',
                time: true,
                merge_logs: true,
                source_map_support: true
              }]
            };
            EOF
            
            # Start the new process
            echo "ðŸš€ Starting new process $NEW_PROCESS on port $NEW_PORT from $STAGING_PATH..."
            pm2 start ecosystem.config.js
            
            # Health check function to wait for the new application to be ready
            health_check() {
              local port=$1
              local attempts=0
              local max_attempts=30
              local HEALTH_CHECK_URL="http://localhost:$port/api/health" # Your API health endpoint
              
              echo "ðŸ” Starting health check on port $port using $HEALTH_CHECK_URL..."
              
              # Loop with retries for health check
              while [ $attempts -lt $max_attempts ]; do
                if curl -f -s --max-time 3 "$HEALTH_CHECK_URL" > /dev/null 2>&1; then
                  echo "âœ… Health check passed on port $port"
                  return 0 # Success
                fi
                attempts=$((attempts + 1))
                echo "ðŸ”„ Health check attempt $attempts/$max_attempts on port $port..."
                sleep 2 # Wait before retrying
              done
              
              echo "âŒ Health check failed after $max_attempts attempts."
              echo "ðŸ” Checking if port $port is listening..."
              netstat -tuln | grep ":$port " || echo "Port $port is not listening."
              echo "ðŸ” Checking PM2 logs for $NEW_PROCESS..."
              pm2 logs $NEW_PROCESS --lines 20 || true # Display recent PM2 logs for debugging
              return 1 # Failure
            }
            
            echo "â³ Giving the new process an initial grace period before health checks..."
            sleep 8 # Initial wait for the app to start up
            
            # Perform health check
            if health_check $NEW_PORT; then
              echo "âœ… New process is healthy on port $NEW_PORT"
              
              # Update Nginx upstream configuration to point to the new port
              echo "ðŸ”„ Updating Nginx to point to port $NEW_PORT..."
              sudo tee "/etc/nginx/conf.d/test1_backend.conf" > /dev/null << EOF
              upstream test1_backend {
                  server 127.0.0.1:$NEW_PORT;
              }
              EOF
              
              # Test and reload Nginx configuration
              if sudo nginx -t; then # Test Nginx config syntax
                sudo nginx -s reload # Reload Nginx gracefully
                echo "âœ… Nginx reloaded successfully"
                
                echo "â³ Waiting for Nginx to fully pick up changes before external verification..."
                sleep 3 # Give Nginx a moment
                
                # Verify external access after Nginx switch
                if curl -f -s --max-time 5 "https://test1.api.change-networks.com/api/health" > /dev/null 2>&1; then
                  echo "âœ… Traffic successfully switched to new version!"
                  
                  # Stop and delete the old process if it exists
                  if pm2 describe $OLD_PROCESS > /dev/null 2>&1; then
                    echo "ðŸ›‘ Gracefully stopping old process: $OLD_PROCESS"
                    pm2 stop $OLD_PROCESS
                    sleep 2 # Give it a moment to stop
                    pm2 delete $OLD_PROCESS
                  else
                    echo "Old process $OLD_PROCESS not found or already stopped."
                  fi
                  
                  # Atomically move the existing current deployment to backup
                  if [ -d "$CURRENT_PATH" ] && [ "$(ls -A $CURRENT_PATH 2>/dev/null)" ]; then
                    echo "ðŸ—‘ï¸ Moving existing current deployment to backup: $CURRENT_PATH -> $BACKUP_PATH"
                    rm -rf "$BACKUP_PATH" # Clear any previous backup first
                    mv "$CURRENT_PATH" "$BACKUP_PATH"
                  else
                    echo "Current deployment directory ($CURRENT_PATH) does not exist or is empty; no backup needed."
                  fi

                  # Move the newly deployed staging directory to current
                  echo "ðŸš€ Moving staging deployment to current: $STAGING_PATH -> $CURRENT_PATH"
                  mv "$STAGING_PATH" "$CURRENT_PATH"
                  
                  # Recreate the empty staging directory for the next deployment
                  mkdir -p "$STAGING_PATH"
                  
                  # CRITICAL: Update PM2 process to point to the new 'current' path
                  # This ensures PM2's internal state accurately reflects the process's actual location.
                  echo "ðŸ”„ Updating PM2 process $NEW_PROCESS to use current path: $CURRENT_PATH"
                  
                  # Change into the new current directory to generate ecosystem.config.js
                  # This ensures the `cwd` in the PM2 config will point to the new `CURRENT_PATH`
                  cd "$CURRENT_PATH" 
                  
                  # Re-create the ecosystem.config.js file in the CURRENT_PATH
                  # This is crucial for PM2 to correctly update its internal process state.
                  cat > ecosystem.config.js << EOF
                  module.exports = {
                    apps: [{
                      name: '$NEW_PROCESS',
                      script: '$CURRENT_PATH/node_modules/.bin/next',
                      args: 'start',
                      cwd: '$CURRENT_PATH', # Explicitly set CWD to the final path
                      instances: 1,
                      exec_mode: 'cluster',
                      env: {
                        NODE_ENV: 'production',
                        PORT: '$NEW_PORT',
                        PWD: '$CURRENT_PATH', # Update PWD environment variable
                        NEXT_TELEMETRY_DISABLED: '1'
                      },
                      max_memory_restart: '512M',
                      min_uptime: '10s',
                      max_restarts: 3,
                      autorestart: true,
                      watch: false,
                      kill_timeout: 8000,
                      wait_ready: true,
                      listen_timeout: 15000,
                      error_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-error.log',
                      out_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-out.log',
                      log_file: '$DEPLOY_PATH/logs/$NEW_PROCESS.log',
                      time: true,
                      merge_logs: true,
                      source_map_support: true
                    }]
                  };
                  EOF
                  
                  # Restart the process using the newly generated config in the correct CWD
                  # This updates PM2's internal records for the process's working directory.
                  pm2 restart ecosystem.config.js --update-env # --update-env ensures new env vars are applied
                  
                  # Save PM2 configuration to persist changes across server reboots
                  pm2 save
                  
                  echo "ðŸŽ‰ Zero-downtime deployment completed successfully!"
                  echo "ðŸ“Š Active process: $NEW_PROCESS on port $NEW_PORT"
                  echo "ðŸ“‚ Working directory: $CURRENT_PATH"
                  
                else
                  echo "âŒ External health check failed after Nginx switch. Rolling back Nginx."
                  
                  # Rollback Nginx config to the old port if traffic switch verification fails
                  if [ -n "$CURRENT_PORT" ]; then
                    echo "ðŸ”„ Rolling back Nginx to port $CURRENT_PORT..."
                    sudo tee "/etc/nginx/conf.d/test1_backend.conf" > /dev/null << EOF
                    upstream test1_backend {
                        server 127.0.0.1:$CURRENT_PORT;
                    }
                    EOF
                    sudo nginx -s reload
                    echo "âœ… Nginx rolled back successfully."
                  fi
                  
                  # Stop and delete the newly deployed (and failing) process
                  echo "ðŸ›‘ Stopping failed new process: $NEW_PROCESS"
                  pm2 stop $NEW_PROCESS || true # Use || true to prevent script failure if process isn't running
                  pm2 delete $NEW_PROCESS || true
                  
                  exit 1 # Indicate failure
                fi
              else
                echo "âŒ Nginx configuration test failed. Not reloading Nginx. Stopping new process."
                pm2 stop $NEW_PROCESS || true
                pm2 delete $NEW_PROCESS || true
                exit 1 # Indicate failure
              fi
              
            else
              echo "âŒ New process failed initial health check. Not switching traffic. Stopping new process."
              pm2 stop $NEW_PROCESS || true
              pm2 delete $NEW_PROCESS || true
              exit 1 # Indicate failure
            fi
          DEPLOY_SCRIPT

      - name: ðŸ” Verify Deployment
        run: |
          ssh deploy << 'VERIFY_SCRIPT'
            echo "ðŸ“Š PM2 Status:"
            pm2 status || echo "PM2 is not running or status command failed."
            
            echo ""
            echo "ðŸŒ External Health Check (via Nginx reverse proxy):"
            curl -s https://test1.api.change-networks.com/api/health || echo "External health check failed."
            
            echo ""
            echo "ðŸ”§ Nginx Upstream Config:"
            cat /etc/nginx/conf.d/test1_backend.conf || echo "Nginx config file not found."
            
            echo ""
            echo "ðŸ“‹ Active Processes Listening on Ports 5005/5006:"
            netstat -tuln | grep -E ':(5005|5006) ' || echo "No processes listening on 5005 or 5006."
            
            echo ""
            echo "ðŸ”— Current Deployment Directory Contents:"
            ls -la ${{ env.DEPLOY_PATH }}/current || echo "Current deployment directory not found or empty."
          VERIFY_SCRIPT

      - name: ðŸ§¹ Cleanup
        if: always()
        run: |
          # Clean up local artifacts and SSH key
          rm -f ~/.ssh/deploy_key deployment.tar.gz
          echo "âœ… Local cleanup completed"

  notify:
    needs: [build, deploy]
    runs-on: self-hosted
    if: always() # This job will always run, regardless of previous job success/failure
    steps:
      - name: ðŸ“¢ Deployment Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "ðŸŽ‰ Test1 API deployment successful!"
            echo "ðŸ†” ID: ${{ needs.build.outputs.deployment-id }}"
            echo "ðŸŒ Environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}"
            echo "ðŸ”— URL: https://test1.api.change-networks.com"
          else
            echo "âŒ Test1 API deployment failed!"
            echo "ðŸ†” ID: ${{ needs.build.outputs.deployment-id }}"
            echo "ðŸ” Check the 'Deploy' job logs above for details on the failure."
          fi