name: âš¡ Test1 API Ultra-Fast Deploy

on:
  push:
    branches: [main, dev]

env:
  NODE_VERSION: '18'
  CACHE_VERSION: 'v2'  # Bumped version to invalidate old cache

jobs:
  build:
    runs-on: self-hosted
    outputs:
      deployment-id: ${{ steps.meta.outputs.deployment-id }}
      cache-hit: ${{ steps.cache-check.outputs.cache-hit }}
    steps:
      - name: ğŸ“‹ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ğŸ“Š Generate Metadata
        id: meta
        run: |
          DEPLOYMENT_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA:0:7}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "ğŸ†” Deployment ID: $DEPLOYMENT_ID"

      - name: âš¡ Setup Node.js with Cache
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ”„ Cache Dependencies Only
        id: cache-deps
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ env.CACHE_VERSION }}-deps-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-deps-${{ runner.os }}-

      - name: ğŸ”„ Cache Build Output
        id: cache-check
        uses: actions/cache@v3
        with:
          path: .next
          key: ${{ env.CACHE_VERSION }}-build-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx', '**/*.json', '!node_modules/**') }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-build-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-

      - name: ğŸš€ Install Dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: |
          npm ci --prefer-offline --no-audit --no-fund --silent --progress=false
          echo "ğŸ“¦ Dependencies installed"

      - name: ğŸ—ï¸ Build Application
        if: steps.cache-check.outputs.cache-hit != 'true'
        run: |
          NODE_ENV=production npm run build
          echo "âœ… Build completed"

      - name: ğŸ“¦ Create Optimized Package
        run: |
          echo "ğŸ“¦ Creating optimized package..."
          
          # Verify build exists
          if [ ! -d ".next" ]; then
            echo "âŒ .next directory not found! Build may have failed."
            exit 1
          fi
          
          # Show build info
          echo "ğŸ“Š Build info:"
          echo "  - .next size: $(du -sh .next | cut -f1)"
          echo "  - node_modules size: $(du -sh node_modules | cut -f1)"
          
          tar -czf deployment.tar.gz \
            --exclude='node_modules/.cache' \
            --exclude='node_modules/*/test*' \
            --exclude='node_modules/*/docs' \
            --exclude='node_modules/*/*.md' \
            --exclude='.next/cache' \
            .next \
            node_modules \
            public \
            package.json \
            next.config.*
          echo "ğŸ“¦ Package size: $(du -sh deployment.tar.gz | cut -f1)"

      - name: ğŸš€ Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ steps.meta.outputs.deployment-id }}
          path: deployment.tar.gz
          retention-days: 1
          compression-level: 1

  deploy:
    needs: build
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: ğŸ“¥ Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-${{ needs.build.outputs.deployment-id }}
          path: .

      - name: âš™ï¸ Setup Environment Variables
        id: env-setup
        run: |
          BRANCH=${GITHUB_REF##*/}
          
          if [ "$BRANCH" = "main" ]; then
            # Production environment
            SERVER="${{ secrets.PROD_DOMAIN }}" 
            USER="${{ secrets.PROD_SERVER_USER }}"
            PORT_SSH="${{ secrets.PROD_SSH_PORT }}"
            DEPLOY_PATH="${{ secrets.PROD_SERVER_PATH }}"
            PROCESS_NAME="${{ secrets.PROD_PROCESS_NAME }}"
            PORT_A="${{ secrets.PROD_PORT_A }}"
            PORT_B="${{ secrets.PROD_PORT_B }}"
            DOMAIN="${{ secrets.PROD_DOMAIN }}"
            ENV_SECRET="${{ secrets.PROD_ENV_SECRET }}"
            SSH_KEY="${{ secrets.PROD_SSH_PRIVATE_KEY }}"
            NGINX_CONF=""test1_backend".conf"
          else
            # Development environment
            SERVER="${{ secrets.DEV_DOMAIN }}"
            USER="${{ secrets.DEV_SERVER_USER }}"
            PORT_SSH="${{ secrets.DEV_SSH_PORT }}"
            DEPLOY_PATH="${{ secrets.DEV_SERVER_PATH }}"
            PROCESS_NAME="${{ secrets.DEV_PROCESS_NAME }}"
            PORT_A="${{ secrets.DEV_PORT_A }}"
            PORT_B="${{ secrets.DEV_PORT_B }}"
            DOMAIN="${{ secrets.DEV_DOMAIN }}"
            ENV_SECRET="${{ secrets.DEV_ENV_SECRET }}"
            SSH_KEY="${{ secrets.DEV_SSH_PRIVATE_KEY }}"
            NGINX_CONF="test1_dev_backend.conf"
          fi
          
          # Validate required variables
          if [ -z "$SERVER" ]; then
            echo "âŒ SERVER is not set. Please add SERVER_HOST to your repository secrets."
            exit 1
          fi
          
          if [ -z "$USER" ]; then
            echo "âŒ USER is not set. Please add SERVER_USER to your repository secrets."
            exit 1
          fi
          
          if [ -z "$PORT_SSH" ]; then
            echo "âš ï¸ PORT_SSH is not set, defaulting to 22"
            PORT_SSH="22"
          fi
          
          if [ -z "$SSH_KEY" ]; then
            echo "âŒ SSH_KEY is not set. Please add SSH_PRIVATE_KEY to your repository secrets."
            exit 1
          fi
          
          # Set outputs for use in later steps
          echo "server=$DOMAIN" >> $GITHUB_OUTPUT
          echo "user=$USER" >> $GITHUB_OUTPUT
          echo "port=$PORT_SSH" >> $GITHUB_OUTPUT
          echo "deploy-path=$DEPLOY_PATH" >> $GITHUB_OUTPUT
          echo "process-name=$PROCESS_NAME" >> $GITHUB_OUTPUT
          echo "port-a=$PORT_A" >> $GITHUB_OUTPUT
          echo "port-b=$PORT_B" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          
          # Set environment variables for this job
          echo "DEPLOYMENT_ID=${{ needs.build.outputs.deployment-id }}" >> $GITHUB_ENV
          echo "SERVER=$DOMAIN" >> $GITHUB_ENV
          echo "USER=$USER" >> $GITHUB_ENV
          echo "PORT_SSH=$PORT_SSH" >> $GITHUB_ENV
          echo "DEPLOY_PATH=$DEPLOY_PATH" >> $GITHUB_ENV
          echo "PROCESS_NAME=$PROCESS_NAME" >> $GITHUB_ENV
          echo "PORT_A=$PORT_A" >> $GITHUB_ENV
          echo "PORT_B=$PORT_B" >> $GITHUB_ENV
          echo "domain=$DOMAIN" >> $GITHUB_ENV

      - name: ğŸ” Setup SSH Configuration
        run: |
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Determine which SSH key to use based on branch
          BRANCH=${GITHUB_REF##*/}
          if [ "$BRANCH" = "main" ]; then
            SSH_KEY='${{ secrets.PROD_SSH_PRIVATE_KEY }}'
          else
            SSH_KEY='${{ secrets.DEV_SSH_PRIVATE_KEY }}'
          fi
          
          # Write SSH private key
          echo "$SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify SSH key format
          if ! ssh-keygen -l -f ~/.ssh/deploy_key >/dev/null 2>&1; then
            echo "âŒ Invalid SSH key format"
            exit 1
          fi
          
          # Validate server hostname
          if [ -z "${{ steps.env-setup.outputs.server }}" ]; then
            echo "âŒ Server hostname is empty. Please check your repository secrets."
            exit 1
          fi
          
          # Create SSH config with validated hostname
          cat > ~/.ssh/config << EOF
          Host deploy
            HostName ${{ steps.env-setup.outputs.server }}
            User ${{ steps.env-setup.outputs.user }}
            Port ${{ steps.env-setup.outputs.port }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            ServerAliveInterval 30
            ConnectTimeout 10
            Compression yes
          EOF
          
          # Verify SSH config
          echo "ğŸ” SSH Config:"
          cat ~/.ssh/config
          
          # Test SSH connection
          echo "ğŸ” Testing SSH connection to ${{ steps.env-setup.outputs.server }}..."
          if ssh -o BatchMode=yes -o ConnectTimeout=10 deploy "echo 'SSH connection successful'"; then
            echo "âœ… SSH connection test passed"
          else
            echo "âŒ SSH connection test failed"
            exit 1
          fi

      - name: ğŸ§¹ Clean Old Deployments First
        run: |
          echo "ğŸ§¹ Cleaning old deployments (keeping only 2 most recent)..."
          ssh deploy "cd ${{ steps.env-setup.outputs.deploy-path }}/deployments 2>/dev/null && ls -t | tail -n +3 | xargs -r rm -rf || echo 'No old deployments to clean'"

      - name: ğŸš€ Deploy Application
        run: |
          DEPLOY_DIR="${{ env.DEPLOYMENT_ID }}"
          
          echo "ğŸ“¤ Creating deployment directory: $DEPLOY_DIR"
          ssh deploy "mkdir -p ${{ steps.env-setup.outputs.deploy-path }}/deployments/$DEPLOY_DIR"
          
          echo "ğŸ“¤ Uploading deployment package..."
          scp -C deployment.tar.gz deploy:${{ steps.env-setup.outputs.deploy-path }}/deployments/$DEPLOY_DIR/deployment.tar.gz
          
          # Copy environment variables based on branch
          BRANCH=${GITHUB_REF##*/}
          if [ "$BRANCH" = "main" ]; then
            echo '${{ secrets.PROD_ENV_SECRET }}' | ssh deploy "cat > ${{ steps.env-setup.outputs.deploy-path }}/deployments/$DEPLOY_DIR/.env"
          else
            echo '${{ secrets.DEV_ENV_SECRET }}' | ssh deploy "cat > ${{ steps.env-setup.outputs.deploy-path }}/deployments/$DEPLOY_DIR/.env"
          fi
          
          # Execute deployment script
          ssh deploy << 'DEPLOY_SCRIPT'
            set -e
            
            # Setup paths
            DEPLOY_PATH="${{ steps.env-setup.outputs.deploy-path }}"
            DEPLOYMENT_ID="${{ env.DEPLOYMENT_ID }}"
            NEW_DEPLOYMENT_PATH="$DEPLOY_PATH/deployments/$DEPLOYMENT_ID"
            CURRENT_PATH="$DEPLOY_PATH/current"
            STAGING_PATH="$DEPLOY_PATH/staging"
            
            echo "ğŸ—ï¸ Setting up deployment paths..."
            echo "ğŸ“‚ New deployment: $NEW_DEPLOYMENT_PATH"
            echo "ğŸ“‚ Current: $CURRENT_PATH"
            echo "ğŸ“‚ Staging: $STAGING_PATH"
            
            # Create directories
            mkdir -p "$NEW_DEPLOYMENT_PATH" "$CURRENT_PATH" "$STAGING_PATH" "$DEPLOY_PATH/logs"
            
            cd "$NEW_DEPLOYMENT_PATH"
            
            # Extract package
            echo "ğŸ“¦ Extracting package..."
            tar -xzf deployment.tar.gz && rm deployment.tar.gz
            
            # Verify critical files
            [ ! -f "package.json" ] && { echo "âŒ package.json missing"; exit 1; }
            [ ! -d ".next" ] && { echo "âŒ .next directory missing"; exit 1; }
            
            # Show build timestamp to verify it's fresh
            echo "âœ… Package extracted and verified"
            echo "ğŸ“… Build timestamp: $(stat -c %y .next/BUILD_ID 2>/dev/null || echo 'N/A')"
            echo "ğŸ” Deployment ID in package: $DEPLOYMENT_ID"
            
            # Smart detection of deployment type
            FIRST_DEPLOYMENT=false
            OLD_PROCESS=""
            CURRENT_PORT=""
            
            # Check for existing processes with our process name pattern
            EXISTING_PROCESSES=$(pm2 list | grep "${{ steps.env-setup.outputs.process-name }}" | grep "online" || true)
            
            if [ -z "$EXISTING_PROCESSES" ]; then
              echo "ğŸ¯ No running processes found - First deployment or recovery"
              FIRST_DEPLOYMENT=true
            else
              echo "ğŸ”„ Found existing processes - Regular update"
              # Get current port from Nginx config
              if [ -f "/etc/nginx/conf.d/"$NGINX_CONF".conf" ]; then
                CURRENT_PORT=$(grep -o "127.0.0.1:[0-9]*" /etc/nginx/conf.d/"$NGINX_CONF".conf | cut -d: -f2)
                echo "ğŸ“ Current Nginx port: $CURRENT_PORT"
              fi
            fi
            
            # Determine ports and processes
            if [ "$FIRST_DEPLOYMENT" = true ]; then
              NEW_PORT="${{ steps.env-setup.outputs.port-a }}"
              NEW_PROCESS="${{ steps.env-setup.outputs.process-name }}-a"
              OLD_PROCESS=""
              echo "ğŸš€ First deployment: Using port $NEW_PORT with process $NEW_PROCESS"
            else
              # Switch ports for zero-downtime
              if [ "$CURRENT_PORT" = "${{ steps.env-setup.outputs.port-a }}" ]; then
                NEW_PORT="${{ steps.env-setup.outputs.port-b }}"
                NEW_PROCESS="${{ steps.env-setup.outputs.process-name }}-b"
                OLD_PROCESS="${{ steps.env-setup.outputs.process-name }}-a"
              else
                NEW_PORT="${{ steps.env-setup.outputs.port-a }}"
                NEW_PROCESS="${{ steps.env-setup.outputs.process-name }}-a"
                OLD_PROCESS="${{ steps.env-setup.outputs.process-name }}-b"
              fi
              echo "ğŸ”„ Port switch: $CURRENT_PORT â†’ $NEW_PORT"
              echo "ğŸ”„ Process switch: $OLD_PROCESS â†’ $NEW_PROCESS"
            fi
            
            # Add environment variables
            echo "PORT=$NEW_PORT" >> .env
            echo "NODE_ENV=production" >> .env
            echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> .env
            
            # Create PM2 config
            cat > ecosystem.config.cjs << EOF
          module.exports = {
            apps: [{
              name: '$NEW_PROCESS',
              script: './node_modules/.bin/next',
              args: 'start',
              cwd: '$NEW_DEPLOYMENT_PATH',
              instances: 1,
              env: {
                NODE_ENV: 'production',
                PORT: '$NEW_PORT',
                NEXT_TELEMETRY_DISABLED: '1'
              },
              max_memory_restart: '512M',
              min_uptime: '5s',
              max_restarts: 3,
              autorestart: true,
              watch: false,
              kill_timeout: 5000,
              wait_ready: true,
              listen_timeout: 8000,
              error_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-error.log',
              out_file: '$DEPLOY_PATH/logs/$NEW_PROCESS-out.log',
              time: true
            }]
          };
          EOF
            
            # Start new process
            echo "ğŸš€ Starting $NEW_PROCESS on port $NEW_PORT..."
            pm2 start ecosystem.config.cjs
            
            # Health check function
            health_check() {
              local port=$1
              local max_attempts=$2
              local interval=$3
              
              echo "ğŸ” Health check on port $port (max $max_attempts attempts)..."
              
              for i in $(seq 1 $max_attempts); do
                if curl -f -s --max-time 2 "http://localhost:$port/api/health" >/dev/null 2>&1; then
                  echo "âœ… Health check passed on port $port (attempt $i)"
                  return 0
                fi
                echo "ğŸ”„ Health check attempt $i/$max_attempts on port $port..."
                sleep $interval
              done
              
              echo "âŒ Health check failed after $max_attempts attempts"
              return 1
            }
            
            # Local health check
            if [ "$FIRST_DEPLOYMENT" = true ]; then
              # More lenient for first deployment
              if ! health_check $NEW_PORT 30 2; then
                echo "âŒ First deployment health check failed"
                pm2 logs $NEW_PROCESS --lines 50
                pm2 delete $NEW_PROCESS
                exit 1
              fi
            else
              # Standard for updates
              if ! health_check $NEW_PORT 20 1; then
                echo "âŒ Update health check failed"
                pm2 logs $NEW_PROCESS --lines 20
                pm2 delete $NEW_PROCESS
                exit 1
              fi
            fi
            
            # Update Nginx config
            echo "ğŸ”„ Updating Nginx to point to port $NEW_PORT..."
            sudo tee "/etc/nginx/conf.d/"$NGINX_CONF".conf" > /dev/null << EOF
          upstream "$NGINX_CONF" {
              server 127.0.0.1:$NEW_PORT;
          }
          EOF
            
            # Test and reload Nginx
            if sudo nginx -t; then
              sudo nginx -s reload
              echo "âœ… Nginx reloaded successfully"
              sleep 3
              
              # Always proceed with deployment since local health check passed
              echo "âœ… Local health check passed, proceeding with deployment"
              
              # Stop old process if it exists and this is an update
              if [ "$FIRST_DEPLOYMENT" = false ] && [ -n "$OLD_PROCESS" ]; then
                if pm2 describe $OLD_PROCESS >/dev/null 2>&1; then
                  echo "ğŸ›‘ Stopping old process: $OLD_PROCESS"
                  pm2 stop $OLD_PROCESS
                  sleep 1
                  pm2 delete $OLD_PROCESS
                else
                  echo "â„¹ï¸ Old process $OLD_PROCESS not found (already stopped)"
                fi
              fi
              
              # Update symlinks and staging
              echo "ğŸ”„ Updating symlinks..."
              [ -L "$CURRENT_PATH" ] && rm "$CURRENT_PATH"
              ln -sfn "$NEW_DEPLOYMENT_PATH" "$CURRENT_PATH"
              
              echo "ğŸ”„ Updating staging directory..."
              rm -rf "$STAGING_PATH"/* 2>/dev/null || true
              cp -r "$NEW_DEPLOYMENT_PATH"/* "$STAGING_PATH/"
              
              # Save PM2 and cleanup
              pm2 save
              
              # Keep only 2 most recent deployments (final cleanup)
              echo "ğŸ§¹ Final cleanup - keeping only 2 most recent deployments..."
              cd "$DEPLOY_PATH/deployments" && ls -t | tail -n +3 | xargs -r rm -rf
              
              echo "ğŸ‰ Deployment completed successfully!"
              echo "ğŸ“‚ Current deployments:"
              ls -la "$DEPLOY_PATH/deployments"
              
            else
              echo "âŒ Nginx configuration test failed"
              pm2 delete $NEW_PROCESS
              exit 1
            fi
          DEPLOY_SCRIPT

      - name: ğŸ” Verify Deployment
        run: |
          ssh deploy << 'VERIFY_SCRIPT'
            echo "ğŸ“Š PM2 Status:"
            pm2 status | grep "${{ steps.env-setup.outputs.process-name }}" || echo "No processes found"
            
            echo ""
            echo "ğŸ”§ Nginx Config:"
            cat /etc/nginx/conf.d/"$NGINX_CONF".conf 2>/dev/null || echo "No Nginx config"
            
            echo ""
            echo "ğŸ“‚ Deployment Directory (should show only 2 most recent):"
            ls -la ${{ steps.env-setup.outputs.deploy-path }}/deployments
            
            echo ""
            echo "ğŸ“‚ Current Symlink:"
            ls -la ${{ steps.env-setup.outputs.deploy-path }}/current
            
            echo ""
            echo "ğŸ“‚ Staging Directory:"
            ls -la ${{ steps.env-setup.outputs.deploy-path }}/staging
            
            echo ""
            echo "ğŸŒ Health Check Test:"
            curl -s "https://${{ steps.env-setup.outputs.domain }}/api/health" || echo "External health check failed"
          VERIFY_SCRIPT

      - name: ğŸ§¹ Cleanup
        if: always()
        run: rm -f ~/.ssh/deploy_key deployment.tar.gz

  notify:
    needs: [build, deploy]
    runs-on: self-hosted
    if: always()
    steps:
      - name: ğŸ“¢ Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "ğŸ‰ Deployment successful!"
            echo "âš¡ Cache hit: ${{ needs.build.outputs.cache-hit }}"
            echo "ğŸŒ Environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}"
          else
            echo "âŒ Deployment failed!"
          fi